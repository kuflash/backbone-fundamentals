<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Backbone-fundamentals by sakateka</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/sakateka/backbone-fundamentals">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/sakateka/backbone-fundamentals/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/sakateka/backbone-fundamentals/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Backbone-fundamentals</h1>
          <p>A creative-commons book on Backbone.js for beginners and advanced users alike</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/sakateka">sakateka</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>

        <h1>Разработка Backbone.js Приложений</h1>

<p>Это книга о Backbone.js предназначена для новичков и опытных пользователей.</p>

<p><a href="https://github.com/addyosmani/backbone-fundamentals">Главная ветка</a> книги 'Developing Backbone.js Applications', которая описывает работу с Backbone.js-фреймворком, предназначенным для структурирования JavaScript-приложений. Выпущена под лицензией <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC</a>.</p>

<p><i>(Данный форк является переводом на русский язык. Ввиду отсутствия других переводов, можно считать этот перевод официальным - Прим. Переводчика)</i></p>

<p>Я очень рад, что эта книга через несколько месяцев будет напечатана на бумаге под редакцией <a href="http://oreilly.com">O'Reilly Media</a>. Читатели смогут приобрести последнюю версию книги в печатном формате либо в различных цифровых форматах. Или скачать ее из этого репозитория бесплатно.</p>

<p>Корректировки этого материала всегда приветствуются, и я надеюсь, что вместе мы обеспечим сообщество актуальным на сегодняшний день вспомогательным материалом.</p>

<p>Больше благодарностей <a href="https://github.com/addyosmani/backbone-fundamentals/contributors">этим</a> членам сообщества за их помощь в доводке этого проекта.</p>

<h2>Содержание</h2>

<ul>
<li><p><a href="#introduction">Введение</a></p></li>
<li>
<h4><a href="#fundamentals">Теория</a></h4>

<ul>
<li><a href="#mvc-mvp">Понимание MVC &amp; MVP</a></li>
</ul>
</li>
<li>
<h4><a href="#thebasics">Основы</a></h4>

<ul>
<li><a href="#models">Модели</a></li>
<li><a href="#views">Представления</a></li>
<li><a href="#collections">Коллекции</a></li>
<li><a href="#routers">Маршрутизаторы</a></li>
<li><a href="#namespacing">Пространства имен</a></li>
<li><a href="#additional-tips">Дополнительные советы</a></li>
</ul>
</li>
<li>
<h4><a href="#advanced"> Расширенная часть</a></h4>

<ul>
<li><a href="#restful">Создание RESTful приложений с Backbone</a></li>
<li><a href="#stack1">Набор 1: Используем Node.js, Express, Mongoose и MongoDB</a></li>
<li><a href="#modularjs">Модульный JavaScript</a></li>
<li>Organizing modules with RequireJS and AMD</li>
<li>Keeping your templates external with the RequireJS text plugin</li>
<li>Optimizing Backbone apps for production with the RequireJS Optimizer</li>
<li>Practical: Building a modular Backbone app with AMD &amp; RequireJS</li>
<li>Decoupling Backbone with the Mediator and Facade patterns </li>
<li>Backbone &amp; jQuery Mobile</li>
<li>Practical: Building a modular mobile app with Backbone &amp; jQuery Mobile</li>
</ul>
</li>
<li>
<h4><a href="#testing">Testing</a></h4>

<ul>
<li>Unit Testing Backbone Applications With Jasmine</li>
<li>An Introduction to Jasmine</li>
<li><a href="#testing-models">Testing Models</a></li>
<li><a href="#testing-collections">Testing Collections</a></li>
<li><a href="#testing-views">Testing Views</a></li>
</ul>
</li>
<li><h4><a href="#resources">Resources</a></h4></li>
</ul><h2><a name="introduction">Введение</a></h2>

<p>Как JavaScript-разработчики, мы живем в интересное время, когда не только у нас имеются зрелые решения, помогающие организовать и усилить JavaScript-приложения, базирующиеся на разделении задач. Программисты, работающие над нетривиальными проектами, имеют возможность выбора фреймворка, который поможет им структурировать их приложения.</p>

<p>Зрелость программного обеспечения (фреймворка в частности) заключается не просто в том, на сколько давно этот фреймворк существует, а в том, на сколько этот фреймворк надежен и, что более важно, как хорошо он развивался, чтобы выполнить свою роль. Стал ли он более эффективным при решении общих проблем? Продолжает ли он помогать разработчикам создавать более крупные и сложные приложения?</p>

<p>В этой книге я расскажу о популярном фреймворке Backbone.js, который я считаю лучшим из существующего семейства архитектурных JavaScript-фреймворков.</p>

<p>Темы будут включать в себя MVC теорию, а так же принципы построения приложений с использованием моделей, представлений, коллекций и маршрутизаторов из Backbone. Я также проведу вас по сложным темам, таким как: модульная разработка с использованием Backbone.js и AMD (RequireJS), построение приложений с использованием современного программного стека(Node.js  и Express), разрешение проблем маршрутизации Backbone и jQuery Mobile, советы по инструментам скафолдинга и многое другое.</p>

<p>Если вы узнали о Backbone.js впервые и все еще сомневаетесь, пробовать его или нет, то почему бы не взглянуть на то, как <a href="http://github.com/addyosmani/todomvc">Todo приложение</a> может быть реализовано с помощью Backbone и других популярных фреймворков, прежде, чем читать дальше?</p>

<p>Цель этой книги - создать авторитетное и централизованное хранилище информации, которая может помочь в создании реальных проектов с помощью Backbone. Если вы считаете, что какой-то раздел или тему можно улучшить и расширить то, пожалуйста, не стесняйтесь и выдвигайте предложения. Это не долго и в тоже время поможет другим разработчикам избежать проблем, с которыми вы столкнулись раньше их.</p>

<h2><a name="fundamentals">Теория</a></h2>

<p>В этом разделе мы попробуем разобрать общие принципы, по которым работает Backbone.js. Давайте начнем наше путешествие в лучшее понимание Backbone с осмотра общей архитектуры кода.</p>

<h3><a name="mvc-mvp">Понимание MVC &amp; MVP (Для JavaScript-разработчиков)</a></h3>

<p>Перед началом изучения любого JavaScript-фреймворка, который предназначен для структурирования приложений, полезным будет получение базовых знаний о шаблонах архитектурного проектирования. Шаблон проектирования - это проверенное решение общих проблем разработки, способное предложить разработчикам структурные подходы при организации их приложений.</p>

<p>Шаблоны полезны, поскольку являются набором практик, которые основываются на коллективном опыте квалифицированных разработчиков, решавших подобные проблемы не один раз. И хотя разработчики 10 или 20 лет назад не использовали теже программные языки при реализации шаблонов проектирования в своих проектах, из их усилий мы можем почерпнуть для себя очень много уроков.</p>

<p>В этом разделе мы собираемся рассмотреть два популярных шаблона проектирования - MVC и MVP. Далее в этой книге мы изучим более подробно, как Backbone реализует эти паттерны.</p>

<h2>MVC</h2>

<p>MVC (Model-View-Controller) - это шаблон архитектурного проектирования, который способствует более совершенной организации приложения через разделение ответственности между компонентами. Шаблон обеспечивает отделение бизнес-логики (Модель) от пользовательского интерфейса (Представление) с использованием третьего компонента (Контроллер), который традиционно представляет собой управление логикой пользовательских действий, координирования моделей и представлений. Первоначально шаблон был разработан <a href="http://en.wikipedia.org/wiki/Trygve_Reenskaug">Трюгве Реенскаугом</a>, работавшим над языком программирования Smalltalk-80 (1979). Тогда шаблон был изначально назван Model-View-Controller-Editor. MVC был подробно описан в <a href="http://www.amazon.co.uk/Design-patterns-elements-reusable-object-oriented/dp/0201633612">“Шаблоны проектирования: Элементы повторно используемого объектно-ориентированного ПО”</a> (Часто называемой "GoF" или “Gang of Four”) в 1994 году, что сыграло свою роль в популяризации его использования.</p>

<h3>MVC в Smalltalk-80</h3>

<p>Важно понять, какие проблемы стремился решить оригинальный шаблон MVC и на сколько сильно он изменился с момента его возникновения. В 70-х годах до графического пользовательского интерфейса было еще далеко. Подход, известный как <a href="http://martinfowler.com/eaaDev/uiArchs.html">Раздельные презентации</a> стал использоваться, как средство прозрачного разделения объектных областей, которые моделируют сущности в реальном мире (например, изображение, человек и др.), и презентационные объекты, которые визуализируются на экран пользователя. <i>(Этот абзац возможно переведен криво - Прим.Пер.)</i></p>

<p>Реализация MVC в Smalltalk-80 не остановилась на этой концепции и пошла дальше: была поставлена цель выделения логики приложения из пользовательского интерфейса. Идея заключалась в том, что разделение этих частей приложения позволит повторно использовать модели для других элементов интерфейса. Есть несколько интересных моментов, которые стоит отметить в архитектуре MVC из Smalltalk-80:</p>

<ul>
<li>Элемент Домена, известный как Модель, ничего не знал о пользовательском интерфейсе (Представления и Контроллеры)</li>
<li>Презентация заботилась о Представлениях и Контроллерах, однако не являлась единым представлением и контроллером. Пара Представление-Контроллер была необходима для каждого отображаемого элемента на экране, поэтому между ними не было истинного разделения</li>
<li>Ролью Контроллера в этой паре была обработка пользовательского ввода (например, нажатие клавиши или событие нажатия клика) и последующее какое-либо разумное действие.</li>
<li>Шаблон "Наблюдатель" основывался на обновлении Представления всякий раз, как изменялась Модель.</li>
</ul><p>Разработчики иногда удивляются, узнав, что шаблон "Наблюдатель" (в настоящее время известный как система Издатель-Подписчик) был включен в MVC-архитектуру десятилетия назад. В MVC языка Smalltalk-80 Представление и Контроллер оба наблюдали за Моделью: каждый раз, когда изменялась Модель, Представление на это реагировало. Простой пример такой реализации лежит в основе программ для фондового рынка - для отображения информации в реальном времени любое изменение данных в Модели приложения должно приводить к моментальному обновлению Представления.</p>

<p>Мартин Фаулер провел отличную работу по описанию <a href="http://martinfowler.com/eaaDev/uiArchs.html">оригинального</a> шаблона MVC на протяжении многих лет. И если вы заинтересованы в дальнейшем изучении истории MVC в Smalltalk-80, я рекомендую почитать его работу.</p>

<h2>MVC как мы его знаем</h2>

<p>Мы рассмотрели 70-е года, однако давайте вернемся в нынешнее время. Шаблон MVC был применен в широком спектре языков программирования. Для примера, популярный Ruby on Rails - это реализация фреймворка, основанного на MVC, для создания веб-приложений с помощью языка Rails. JavaScript на данный момент имеет ряд MVC-фреймворков, таких как Ember.js, JavaScriptMVC, и конечно же Backbone.js. Учитывая важность избегания спагетти-кода (термин, характеризующий код, который очень сложно воспринимаем для чтения и трудно поддерживаем из-за отсутствия структуры) давайте посмотрим, что позволяют делать JavaScript-разработчику MVC шаблоны.</p>

<p>MVC состоит из трех основных компонентов:</p>

<h3>Модели</h3>

<p>Модели управляют данными приложения. Они не беспокоятся ни о пользовательском интерфейсе, ни о слоях представлений, но предоставляют структурированные данные, которые могут потребоваться приложению. Когда изменяется модель (например, при ее обновлении), она как правило уведомляет своих наблюдателей (например, Представления - о концепции мы расскажем чуть позже), что произошло изменение, на которое они могут отреагировать.</p>

<p>Чтобы понять модели лучше, давайте представим, что у нас есть JavaScript-приложение: фото-галерея. В фото-галерее фотографии необходима собственная модель, поскольку она представляет собой уникальный вид предметно-ориентированных данных. Модель фотографии может содержать атрибуты, такие как заголовок, источник изображения и другие мета-данные. Конкретные фотографии будут храниться в экземплярах модели. Вот пример простой модели фотографии с использованием Backbone.js:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Атрибуты по умолчанию для фотографии</span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">src</span><span class="o">:</span> <span class="s2">"placeholder.jpg"</span><span class="p">,</span>
      <span class="nx">caption</span><span class="o">:</span> <span class="s2">"A default image"</span><span class="p">,</span>
      <span class="nx">viewed</span><span class="o">:</span> <span class="kc">false</span>
    <span class="p">},</span>

    <span class="c1">// Убедитесь, что каждая фотография имеет заданный путь 'src'</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
       <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="s2">"src"</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">defaults</span><span class="p">.</span><span class="nx">src</span><span class="p">});</span>
    <span class="p">}</span>

<span class="p">});</span>
</pre></div>

<p>Встроенные возможности модели варьируются в зависимости от фреймворка, однако поддержка валидации атрибутов, где атрибуты представляют свойства модели (например, идентификатор модели), является для них общим признаком. При использовании модели в реальном приложении мы, как правило, нуждаемся в сохраняющихся моделях. Сохраняющееся состояние позволяет нам редактировать и обновлять модель, с уверенностью, что модель будет где-либо сохранена, например, в localStorage браузера или синхронизирована с базой сервера.</p>

<p>Модель может так же иметь несколько Представлений-наблюдателей. Представьте нашу модель Фотографии, которая содержит мета-данные о широте и долготе, где она была сделана, список людей, которые отображены на фотографии и список тегов. Разработчик может создать отдельное Представление, которое содержит все эти атрибуты, либо три отдельных Представления выводящих каждый из атрибутов отдельно. Важная деталь в том, что модель Фотографии не волнует, как организованы Представления, она просто оповещает об обновлении ее данных по мере необходимости. Мы вернемся к Представлениям более подробно позже.</p>

<p>Для современных MVC/MV* фреймворков не является редкостью предоставление возможности группировки моделей вместе. В Backbone такие группы называются "Коллекции". Управление моделями в группах позволяет нам писать такую логику приложения, которая основывается на уведомлении изменения моделей из группы. Это позволяет избежать наблюдения вручную за каждым экземпляром модели.</p>

<p>Вот так мы могли бы группировать модели фотографий в упрощенной Коллекции Backbone:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoGallery</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Ссылка на модели этой коллекции</span>
    <span class="nx">model</span><span class="o">:</span> <span class="nx">Photo</span><span class="p">,</span>

    <span class="c1">// Фильтр по списку всех фотографий, которые были просмотрены</span>
    <span class="nx">viewed</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">photo</span><span class="p">){</span> <span class="k">return</span> <span class="nx">photo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'viewed'</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">},</span>

    <span class="c1">// Фильтр только по списку фотографии, которые еще не просматривались</span>
    <span class="nx">unviewed</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">without</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">viewed</span><span class="p">());</span>
    <span class="p">}</span>

<span class="p">});</span>
</pre></div>

<p>Если вы читали старые тексты об MVC, то вы могли столкнуться в описании модели с применением такого способа управления как "состояние". В JavaScript применение "состояния" имеет особое значение, типично относящееся к "состоянию" Представления или Под-представления на экране пользователя в определенное время. Состояние является темой, регулярно поднимаемой при обсуждении одностраничных приложений, в которых концепция состояний должна быть смоделирована.</p>

<h3>Представления</h3>

<p>Представления - это визуальные образы моделей, которые выводят фильтрованное отображение их текущего состояния. Представление обычно наблюдает за моделью и уведомлениями об изменениях модели, соответственно позволяющими представлению обновить себя. В литературе о конструировании шаблонов обычно характеризуют представления, как "тупиц", учитывая их ограниченное знание о моделях и контроллерах в приложении.</p>

<p>Пользовательское взаимодействие с представлениями обычно означает чтение и редактирование данных модели. Например, в нашем примере фото-галереи, представление модели фотографии может происходить посредством большого изображения, заголовка и списка тегов. Редактирование модели может быть произведено через "редактирование" представления, в котором пользователь изменил заголовок, теги или другие мета-данные для выбранной фотографии.</p>

<p>В MVC задача актуального обновления Модели падает на Контроллеры, о которых мы расскажем в ближайшее время.</p>

<p>Давайте чуть дальше рассмотрим Представления на небольшом простом JavaScript-примере. Ниже мы можем видеть, как функция создает Представление для фотографии, взаимодействуя с экземплярами модели и контроллера.</p>

<p>Определим вспомогательную функцию <code>render()</code> внутри нашего представления для отображения данных из модели <code>photoModel</code>, используя JavaScript движок шаблонизации (Underscore templating) и обновляя данные нашего представления, ссылаясь на <code>photoEl</code>. </p>

<p>Затем добавляем в <code>photoModel</code> нашу функцию обратного вызова(колбэк) <code>render()</code> в качестве подписчика, так что с помощью модели "Наблюдатель" представление теперь может реагировать на изменения модели и обновляться.</p>

<p>Вы можете задаться вопросом, а где же здесь вступает в игру взаимодействие с пользователем. Однако не в ответственности представления решать, что делать дальше при клике пользователя на любом его элементе. Это решение принимает Контроллер. В нашем примере реализации это достигается с помощью добавления слушателя события для <code>photoEl</code>, который будет делегировать управление поведением при нажатии контроллеру, передавая информацию о модели, в случае необходимости.</p>

<p>Преимуществом такой архитектуры является разделение роли каждого из компонентов при обеспечении необходимого функционирования приложении.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">buildPhotoView</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">photoModel</span><span class="p">,</span> <span class="nx">photoController</span> <span class="p">){</span>

    <span class="kd">var</span> <span class="nx">base</span>        <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">),</span>
        <span class="nx">photoEl</span>     <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">);</span>

     <span class="nx">base</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">photoEl</span><span class="p">);</span>

     <span class="kd">var</span> <span class="nx">render</span><span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">// Мы используем библиотеку шаблонизации, такую как Underscore</span>
        <span class="c1">// шаблонизатор, который генерирует HTML для нашей</span>
        <span class="c1">// записи фотографии</span>
        <span class="nx">photoEl</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="s1">'photoTemplate'</span><span class="p">,</span> <span class="p">{</span><span class="nx">src</span><span class="o">:</span> <span class="nx">photoModel</span><span class="p">.</span><span class="nx">getSrc</span><span class="p">()});</span>
     <span class="p">}</span>

     <span class="nx">photoModel</span><span class="p">.</span><span class="nx">addSubscriber</span><span class="p">(</span> <span class="nx">render</span> <span class="p">);</span>

     <span class="nx">photoEl</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">photoController</span><span class="p">.</span><span class="nx">handleEvent</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">photoModel</span> <span class="p">);</span>
     <span class="p">});</span>

     <span class="kd">var</span> <span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">photoEl</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span>  <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="kd">var</span> <span class="nx">hide</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">photoEl</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span>  <span class="o">=</span> <span class="s1">'none'</span><span class="p">;</span>
     <span class="p">}</span>


     <span class="k">return</span><span class="p">{</span>
        <span class="nx">showView</span><span class="o">:</span> <span class="nx">show</span><span class="p">,</span>
        <span class="nx">hideView</span><span class="o">:</span> <span class="nx">hide</span>
     <span class="p">}</span>

<span class="p">}</span>
</pre></div>

<p><strong>Шаблонизация</strong></p>

<p>В контексте JavaScript-фреймворков, которые поддерживают MVC/MV*, стоит обратить более пристальное внимание на JavaScript шаблонизацию и ее отношении к Представлениям.</p>

<p>Уже давно считается дурным тоном (и чрезмерной вычислительной нагрузкой) создание больших блоков HTML разметки вручную в памяти через склеивание строковых данных. Разработчики, использующие такую технику часто вынуждены пропускать свои данные через циклы, оборачивать их в дополнительные div'ы и использовать устаревшую технику для вставки "шаблонов" в DOM, такую как <code>document.write</code>. Такой подход означает совмещение сценариев с обычной разметкой в общем коде, что быстро превращает сценарии в трудно читаемые и трудно поддерживаемые, особенно при создании больших приложений.</p>

<p>Библиотеки JavaScript шаблонизаторов (такие как Handlebars.js или Mustache.js) часто используются для определения шаблонов HTML разметки в представлениях в виде переменных. Эти блоки шаблонов могут храниться как вне скрипта, так и в самом скрипте в виде специального типа данных (например, "text/template"). Переменные указываются с помощью специального синтаксиса (например, {{name}}). Библиотеки JavaScript шаболнизации как правило принимают данные в JSON формате, а уже черновую работу по заполнению шаблона данными выполняет сам шаблонный фреймворк. Такой подход имеет ряд преимуществ, особенно когда отдается предпочтение внешнему хранению шаблонов, поскольку это позволяет загружать их динамически по мере необходимости.</p>

<p>Давайте сравним два примера HTML шаблонов. Один из них использует популярную библиотеку Handlebars.js, в то время как второй реализован с использованием библиотеки "микро-шаблонов" Underscore.js.</p>

<p><strong>Handlebars.js:</strong></p>

<div class="highlight"><pre><span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">"photo"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h2&gt;</span>{{caption}}<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"source"</span> <span class="na">src=</span><span class="s">"{{src}}"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"meta-data"</span><span class="nt">&gt;</span> 
    {{metadata}}
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/li&gt;</span>
</pre></div>

<p><strong>Underscore.js микро-шаблоны:</strong></p>

<div class="highlight"><pre><span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">"photo"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h2&gt;</span><span class="err">&lt;</span>%= caption %&gt;<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"source"</span> <span class="na">src=</span><span class="s">"&lt;%= src %&gt;"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"meta-data"</span><span class="nt">&gt;</span> 
    <span class="err">&lt;</span>%= metadata %&gt;
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/li&gt;</span>
</pre></div>

<p>В Микро-шаблонах вы можете также использовать и двойные фигурные скобки (то есть <code>{{}}</code>) (или любой другой способ обозначения переменных в шаблонах, который представляется вам наиболее комфортным). В случае с фигурными скобками, нужно всего навсего указать в настройках Underscore атрибут <code>templateSettings</code> следующим образом:</p>

<div class="highlight"><pre><span class="nx">_</span><span class="p">.</span><span class="nx">templateSettings</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">interpolate</span> <span class="o">:</span> <span class="sr">/\{\{(.+?)\}\}/g</span> <span class="p">};</span>
</pre></div>

<p><strong>Заметка о навигации и состояниях</strong></p>

<p>Стоит также отметить, что в классической веб-разработке навигация между независимыми представлениями требует перезагрузки страницы. В одностраничных JavaScript приложениях загрузив единожды данные с сервера посредством Ajax, они могут динамически визуализироваться в новом представлении на той же странице. Так как это не приводит к обновлению URL, то роль навигации, что логично, выполняет "маршрутизатор", который помогает управлять состояниями приложения (например позволяет пользователям добавлять в закладки страницу с конкретным представлением, к которому они перешли). Маршрутизаторы, тем не менее, не присутствуют в каждом MVC-фреймворке. Я не буду останавливаться на них подробно в этом разделе.</p>

<h3>Контроллеры</h3>

<p>Контроллеры являются посредниками между моделями и представлениями, которые классически выполняют две задачи: они одинаково обновляют представление, когда изменяется модель, и модель, когда пользователь манипулирует представлением.</p>

<p>В нашем приложении фото-галереи контроллер будет отвечать за обработку изменений, которые пользователь совершает в представлении над конкретной фотографией, и обновлять модель фотографии, когда пользователь заканчивает редактирование.</p>

<p>Именно в контроллерах большинство JavaScript MVC фреймворков отходят от основной интерпретации MVC шаблонов. Причины тому разные, но, на мой взгляд, авторы JavaScript фреймворков вероятно сначала взглянули на серверную интерпретацию MVC (например как в Ruby on Rails) и поняли, что не смогут реализовать такой подход один к одному на стороне клиента и пере-интерпретировали роль контроллеров в MVC для решения его проблем с управлением статусов. Они подошли к этому с умом, однако тем самым, возможно, осложнили для разработчиков, которые только начинают вникать в MVC, понимание концепции шаблонов MVC для фреймворков на других языках программирования.</p>

<p>Так есть ли в backbone.js Контроллеры? не совсем. Представления в Backbone как правило содержат в себе логику "контроллеров", в тоже время маршрутизаторы (о них ниже) используются для управления статусами приложения, но они не являются Контроллерами в классическом понимании MVC.</p>

<p>В связи с этим, не смотря на указанное в официальной документации или в записях блога, Backbone не является ни MVC/MVP, ни MVVM фреймворком. Лучше всего воспринимать его членом семейства MV* фреймворков, которые приближаются к изначальной архитектуре по-своему. В этом, конечно же, нет ничего плохого, но важно понимать различия между классическим MVC и MV* когда вы вступаете в обсуждение  ваших backbone проектов и затрагиваете тему MVC.</p>

<h3>Сравнение контроллеров в Spine.js и Backbone.js</h3>

<p><strong>Spine.js</strong></p>

<p>Мы уже знаем, что контроллеры традиционно обновляют представления, когда в моделях происходят изменения и аналогично воздействуют на модель, когда пользователь манипулирует представлением. Мы так же выяснили, что Backbone не имеет <strong>собственного</strong> явного контроллера, поэтому полезно будет взглянуть на контроллеры в других MVC фреймворках, чтобы сравнить реализации. Давайте посмотрим на <a href="http://spinejs.com/">Spine.js</a>:</p>

<p>В этом примере мы создадим контроллер <code>PhotosController</code>, который будет отвечать за изменения отдельных фотографий в приложении. Это будет гарантированно означать, что при обновлении представления (например, пользователь редактирует мета-данные фотографии) соответствующая модель будет делать тоже самое.</p>

<p>(Примечание: Мы не будем сильно углубляться в Spine.js помимо этого примера, но на него стоит взглянуть для большего понимания работы Javascript фреймворков в целом.)</p>

<div class="highlight"><pre><span class="c1">// Контроллеры в Spine создаются путем наследования от Spine.Controller</span>

<span class="kd">var</span> <span class="nx">PhotosController</span> <span class="o">=</span> <span class="nx">Spine</span><span class="p">.</span><span class="nx">Controller</span><span class="p">.</span><span class="nx">sub</span><span class="p">({</span>      
  <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">item</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"update"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">proxy</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">));</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">item</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"destroy"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">proxy</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">remove</span><span class="p">));</span>
  <span class="p">},</span>

  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// Обработка шаблонов</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s2">"#photoTemplate"</span><span class="p">).</span><span class="nx">tmpl</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">item</span><span class="p">));</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="nx">remove</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">release</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>В Spine контроллеры считаются клеем всего приложения: добавляя реакции на события DOM, отрисовывая шаблоны и обеспечивая синхронизацию моделей и представлений (что соответствует тому, что мы узнали о контроллерах в шаблоне MVC).</p>

<p>Вот, что мы делаем в приведенном выше примере: назначаем слушателей для событий <code>update</code> и <code>destroy</code> в виде функций <code>render()</code> и <code>remove()</code> соответственно. Когда запись фотографии обновляется, мы перерисовываем представление, чтобы отразить в нем изменения мета-данных. Аналогично: если фотография будет удалена из галереи, то она должна будет пропасть и в представлении. В случае, если вы задаётесь вопросом о функции <code>tmpl()</code> в отрывке кода: в функции <code>render()</code> мы используем её для преобразования JavaScript шаблона с именем #photoTemplate, она просто возвращает HTML строку, заменяющую текущий элемент контроллера.</p>

<p>Всё это даёт нам очень простой и легкий способ управления изменениями между моделью и представлением.</p>

<p><strong>Backbone.js</strong></p>

<p>Позже в этом разделе мы рассмотрим различия между Backbone и традиционным MVC, но пока что давайте сфокусируемся на контроллерах.</p>

<p>В Backbone логика контроллера распределяется между Backbone.View и Backbone.Router. В ранних релизах Backbone содержался и так называемый и Backbone.Controller, но его переименовали в маршрутизатор, чтобы прояснить его роль.</p>

<p>Основная роль Маршрутизаторов - это перевод URL-запросов в статусы приложения. Когда пользователь переходит по ссылке <a href="http://www.example.com/photos/42">www.example.com/photos/42</a>, Маршрутизатор используется, чтобы показать фотографию с таким ID, и определяет, как себя должно повести приложение в ответ на этот запрос. Маршрутизатор <em>может</em> содержать и традиционные функции контроллера, такие как привязка событий между моделями и представлениями или визуализация отдельных участков страницы. Тем не менее, соучастник проекта Backbone Tim Branyen указал на то, что все это можно реализовывать и без Backbone.Router, поэтому вероятный пример использования контроллера выглядит так:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoRouter</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">routes</span><span class="o">:</span> <span class="p">{</span> <span class="s2">"photos/:id"</span><span class="o">:</span> <span class="s2">"route"</span> <span class="p">},</span>

  <span class="nx">route</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">photoCollection</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhotoView</span><span class="p">({</span> <span class="nx">model</span><span class="o">:</span> <span class="nx">item</span> <span class="p">});</span>

    <span class="nx">something</span><span class="p">.</span><span class="nx">html</span><span class="p">(</span> <span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">().</span><span class="nx">el</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span><span class="o">:</span>
</pre></div>

<h2>Что MVC даст нам?</h2>

<p>Итак, разделение задач в MVC обеспечивает модульность функциональности приложения и включает:</p>

<ul>
<li>Облегчение поддержки кода. Когда должны быть произведены обновления в приложении, это можно сделать прозрачно, делаются ли изменения, ориентированные на данные (то есть изменения в моделях и, возможно, контроллерах) или просто визуальные правки (то есть изменения в представлениях).</li>
<li>Разделение модели и представления означает прямой путь к написанию unit-тестов для бизнес-логики.</li>
<li>Устраняется дублирование кода моделей и контроллеров в приложении.</li>
<li>В зависимости от размера приложения и разделения ролей, такая модульность позволяет разработчикам, занимающимся написанием ядра и разработчикам, работающим над пользовательским интерфейсом, работать одновременно.</li>
</ul><h3>Углубляясь</h3>

<p>Прямо сейчас, вы, скорее всего, уже имеете базовое понимание схемы MVC, однако дальше мы рассмотрим более любопытные моменты.</p>

<p>GoF (Gang of Four) не относятся к MVC, как к шаблону проектирования, а считают это "набором классов для создания пользовательского интерфейса". По их мнению, это вариация из трех других классических шаблонов проектирования: <a href="http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Наблюдатель</a> (Пуб./Подп.), <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Стратегия</a> и <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Компоновщик</a>. В зависимости от того, как был спроектирован MVC в фреймворке, он также может иметь <a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Фабричный метод</a> и <a href="http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Декораторы</a>. Я рассмотрел некоторые из этих моделей в другой моей бесплатной книге "JavaScript Design Patterns For Beginners". Если вы хотите, можете прочитать ее следом.</p>

<p>Как мы уже выяснили, модели представляют собой данные приложения, а представления формируют то, что пользователь увидит на экране.
По существу, MVC полагается на Пуб./Подп. для части его основных взаимодействий (удивительно, что в большинстве статей о MVC шаблонах это не рассматривается). Когда модель изменяется, она "публикует" для остального приложения, что она обновилась. Затем "подписчик" (в общем случае Контроллер) обновляет соответствующим образом Представление. Наблюдатель-представитель, характер этой связи в том, что это облегчает привязку нескольких представлений к одной модели.</p>

<p>Для разработчиков, заинтересованных в получении дополнительных знаний о раздельной природе MVC (опять же, в зависимости от реализации), одна из целей паттерна оказать помощь, в реализации связей один-ко-многим между объектом и его наблюдателями. Когда объект изменяется, его наблюдатели тоже обновляются. Взаимодействия представлений и контроллеров немного отличаются. Контроллеры помогают представлениям реагировать на различный пользовательский ввод и являются примером шаблона <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Стратегия</a></p>

<h3>Выводы</h3>

<p>Рассмотрев классическую MVC модель, вы должны понимать, как она позволяет разработчикам четко разделить задачи в приложении. Также, вы должны представлять себе, чем JavaScript MVC фреймворки могут различаться в своих интерпретациях MVC, и как они расширяют некоторые основные концепции оригинальной схемы.</p>

<p>При рассмотрении нового JavaScript MVC/MV* фреймворка помните - возможно, будет полезно отступиться и рассмотреть какой у него подход к Моделям, Представлениям и Контроллерам или их альтернативам, поскольку это может лучше помочь с выбором используемого фреймворка.</p>

<h2>MVP</h2>

<p>Model-view-presenter (MVP) - производный от MVC шаблон проектирования, который фокусируется на улучшений логики презентации. Он появился в компании именуемой  <a href="http://en.wikipedia.org/wiki/Taligent">Taligent</a> вначале 1990-х, когда они работали над моделью C++ для окружения CommonPoint. И хотя цель MVC и MVP в разделении задач между множеством компонентов, они имеют некоторые фундаментальные различия.</p>

<p>Подводя итоги, мы рассмотрим версию MVP наиболее подходящую для архитектуры веб.</p>

<h3>Модель, Представление &amp; Presenter</h3>

<p>P, в составе MVP, поставлена для Presenter’а. Это компонент, который содержит бизнес логику для пользовательского интерфейса Представления. В отличие от MVC, обращения из представления делегируются Presenter’у, который не связан с представлением, а общается с ним через интерфейс. Это способствует множеству полезных вещей, таких как, возможность проводить над представлениями unit тесты. </p>

<p>Наиболее общая реализация MVP использует пассивные представления (представления для всевозможных целей «манекены»), практически не содержащие логики.
 Модели в MVP практически идентичны моделям в MVC, они обрабатывают данные приложения. Presenter  работает как посредник, общаясь и с представлением, и с моделью, однако, попарно они изолированы друг от друга. Он эффективно связывает модели и представления, обеспечивая функцию Контроллеров в MVC. Presenter  являются сердцем MVP шаблона, и как вы можете догадываться, включают логику отображения представлений. </p>

<p>По запросу представления, Presenter’ы выполняют любую работу с пользовательскими данными и обратно передают им данные. Таким образом, они получают данные, манипулируют с ними и определяют, как данные должны быть отображены в представлении. В некоторых реализациях Presenter  также взаимодействует с серверной частью хранящей данные (модели). Модели могут порождать события, а роль Presenter’ы быть для них подписчиком, и обновлять представления. В пассивной архитектуре мы имеем концепцию прямой привязки данных, Представления предоставляют сеттеры, через которые Presenter’ы могут предоставлять им дынные.</p>

<p>Преимущество этих изменений MVC в увеличении тестируемости ваших приложений, и предоставлении более четкого разделения представления и модели. Однако это имеет и свою цену, отсутствие поддержки привязки данных в шаблоне часто оказывается еще одной задачей, позаботиться о которой надо отдельно.</p>

<p>Несмотря на то, что основная реализация <a href="http://martinfowler.com/eaaDev/PassiveScreen.html">Пассивных представлений</a> - это представления создающие интерфейс, есть различные их варианты, вплоть до событий, которые могут еще больше разделить Presenter’а и Представления. Так как у нас нет интерфейса, построенного на JavaScript, мы будем больше пользоваться им как протоколом, нежели как интерфейсом описанным тут. Технически - это по-прежнему набор  API, и для нас удобнее рассматривать интерфейс с этой точки зрения.</p>

<p>Еще есть разновидность MVP <a href="http://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>, которая ближе к MVC и <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a> шаблонам, так как она предоставляет привязку данных из модели напрямую к представлениям. Модули, отслеживающие пары ключ-значение (KVO) (к примеру Backbone.ModelBinding от Derick Bailey's) внедряют идею Supervising Controller в Backbone.</p>

<h2>MVP или MVC?</h2>

<p>MVP в основном используется в приложениях энтерпрайз уровня, где необходим наибольший процент повторного использования кода в логики представлений. Приложения с очень сложными представлениями и сложным взаимодействием с пользователем могут обнаружить, что MVC не совсем подходит для решения этих задач и в большей степени полагается на многочисленные контроллеры. В MVP вся сложная логика может быть заключена в представлении, которое в дальнейшем намного проще в сопровождении.</p>

<p>В MVP представления определяются через интерфейс и интерфейс технически только точка взаимодействия между системой и представлением (не Presenter’ом), этот паттерн также позволяет разработчикам писать логику представления, не дожидаясь готового каркаса для приложения от дизайнеров.</p>

<p>В зависимости от реализации MVP легче обрабатывается unit-тестами, чем MVC. Это объясняется тем, что Presenter  может быть использован как завершенный макет пользовательского интерфейса и поэтому его можно тестировать отдельно от других компонентов. В моем опыте это зависит от языка, на котором вы реализуете MVP, в этом разница между выбором MVP для проекта на JavaScript и, к примеру, на ASP.net.</p>

<p>В итоге, проблемы, которые мы можем получить при использовании MVP, будут схожи с проблемами в MVC, потому что различаются эти шаблоны только семантически. Чем четче вы разделяете логику между моделями, представлениями и контроллерами (Presenter’ами) тем больше вы получите выгоды, не зависимо от того, какой шаблон проектирования используете.</p>

<h2>MVC, MVP и Backbone.js</h2>

<p>Очень мало архитектурных Фреймворков JavaScript, в которых утверждается реализация MVC или MVP шаблонов в их классической форме, многие JavaScript разработчики не рассматривают MVC и MVP как взаимоисключающие подходы (Более полную реализацию структуры MVP можно увидеть в веб-фреймворках таких как ASP.net или GWT). Причина в  возможности иметь дополнительную логику для Presenter’а/представления в вашем приложении, по-прежнему рассматривая его в красках MVC. </p>

<p>Backbone contributor <a href="http://ireneros.com/">Irene Ros</a> подтверждает этот образ мышления, когда она отделяет Backbone Представления в отдельный компонент, и ей нужно что-то, что обеспечило бы актуальные взаимосвязи с ними. Это могут быть контроллеры маршрутов (такие как <code>Backbone.Router</code>, будет рассмотрен ниже) или callback в ответ на получение данных.</p>

<p>Некоторые разработчики считают, что Backbone.js лучше подходит под описание MVP чем MVC
. Их мнение заключается в следующем:</p>

<ul>
<li>Presenter в MVP лучше объясняет <code>Backbone.View</code> (прослойка между шаблоном Представления и привязанными к нему данными) чем контроллер в MVC.</li>
<li>Модели соответствуют <code>Backbone.Model</code> (они не имеют различий с классическими «Моделями» MVC)<br>
</li>
<li>Представления наилучшим образом представлены шаблонами (т.к. Handlebars/Mustache шаблоны)</li>
</ul><p>Ответом на этом может послужить то, что представления могут быть просто Представлениями (как в MVC) потому что Backbone достаточно гибкий, чтобы использовать их для различных целей. V в MVC и P в MVP оба могут реализовываться <code>Backbone.View</code> он в состоянии реализовать две эти сущности: могут создавать отдельные представления и объединять несколько представлений в одном.</p>

<p>Мы также видели, что в Backbone обязанности контроллеров разделены между Backbone.View и Backbone.Router и в следующем примере мы можем убедиться, что это действительно так.</p>

<p>Наш Backbone <code>PhotoView</code> шаблон Наблюдателя чтобы 'подписаться' на изменения в Модели данного Представления  <code>this.model.bind('change',...)</code>. Тут также обрабатываются шаблоны методом <code>render()</code>, но, в отличии от некоторых других реализации, взаимодействия с пользователем также обрабатываются в Представлении (см. <code>events</code>).</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">//... тег списка.</span>
    <span class="nx">tagName</span><span class="o">:</span>  <span class="s2">"li"</span><span class="p">,</span>

    <span class="c1">//Пропускаем содержимое шаблона photo-template через функцию </span>
    <span class="c1">// шаблонизатора, кэширующего его для одной фотографии.</span>
    <span class="nx">template</span><span class="o">:</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#photo-template'</span><span class="p">).</span><span class="nx">html</span><span class="p">()),</span>

    <span class="c1">// Определяем специфичные для Представления события DOM</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"click img"</span> <span class="o">:</span> <span class="s2">"toggleViewed"</span>
    <span class="p">},</span>

    <span class="c1">// PhotoView слушает изменения и перерисовывается (пр. перев. re-rendering).</span>
    <span class="c1">// Поскольку в этом приложений выполнено однозначное соответствие между **Photo** </span>
    <span class="c1">// и **PhotoView**, мы используем прямые ссылки на модели для удобства. </span>

    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">_</span><span class="p">.</span><span class="nx">bindAll</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">'render'</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'change'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'destroy'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">remove</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="c1">// Перерисовать элемент photo </span>
    <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()));</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>

    <span class="c1">// Переключение состояния `"viewed"` у модели.</span>
    <span class="nx">toggleViewed</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">viewed</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">});</span>
</pre></div>

<p>Другое, (полностью отличающееся) мнение состоит в том, что у Backbone больше сходства с <a href="http://martinfowler.com/eaaDev/uiArchs.html#ModelViewController">Smalltalk-80 MVC</a>, который мы рассматривали ранее.</p>

<p>Активный пользователь Backbone Derick Bailey <a href="http://lostechies.com/derickbailey/2011/12/23/backbone-js-is-not-an-mvc-framework/">написал</a>, что лучше всего не приписывать Backbone каких-либо специфичных шаблонов разработки. Дизайн шаблонов проектирования должен обладать гибкостью относительно структурирования приложения, и в соответствии с этим Backbone не имеет четкого соответствия с MVC или MVP. Вместо этого он заимствует лучшие концепции из различных архитектурных шаблонов и создает гибкую структуру, которая просто хорошо работает. Назовем это **Путь Backbone **, MV* или подобным образом, что лучше отразит особенности архитектуры приложения. </p>

<p><em>Но</em>, стоит понимать, где и почему возникли эти понятия, и я надеюсь, что мои объяснения MVC и MVP помогут вам в этом. Различные JavaScript Фреймворков будут иметь в своей основе различные классические шаблоны, намеренно или случайно, но главное в том, что они позволяют нам разрабатывать структурированные, простые в поддержке приложения с чистым и читаемым кодом. </p>

<h2>Краткие итоги</h2>

<h3>Backbone.js</h3>

<ul>
<li>Основные составляющие компоненты: Модель, Представление, Коллекция, Маршрутизатор. Собственный стиль MV*</li>
<li>Хорошая и постоянно улучшаемая документация<br>
</li>
<li>Используется большими компаниями, такими как SoundCloud и Foursquare, для создания нетривиальных приложений.</li>
<li>Событийно-ориентированные взаимодействия между представлениями и моделями. Как будет видно позднее, это позволяет напрямую добавлять слушателей событий к любым атрибутам модели, что дает разработчикам возможность детального контроля над изменениями в представлениях.</li>
<li>Поддержка привязки данных через самостоятельно созданные события либо специальной библиотекой для наблюдения связей ключ-значение (KVO). (пр. пре. Key-value observing)</li>
<li>Прекрасная поддержка RESTful интерфейса из коробки, обеспечивает легкое связывание модели с бакэндом.</li>
<li>Обширная система регистрации событий. Добавить поддержку пуб./под. в Backbone - это <a href="http://lostechies.com/derickbailey/2011/07/19/references-routing-and-the-event-aggregator-coordinating-views-in-backbone-js/">обычное дело</a> - </li>
<li>Экземпляры прототипов по ключевому слову <code>new</code>.</li>
<li>Не имеет привязки к какому-то определенному шаблонизатору, но шаблонизатор Underscore предоставляется по умолчанию. Backbone хорошо работает с библиотеками, подобными Handlebars</li>
<li>Не поддерживает вложенных моделей, для этого есть плагины к Backbone, например <a href="https://github.com/PaulUithol/Backbone-relational">этот</a> which can help<br>
</li>
<li>Ясные и гибкие соглашения о структурировании приложений. Backbone не заставляет использовать все компоненты, и позволяет работать только с необходимым набором.</li>
</ul><h2><a name="thebasics">Основы</a></h2>

<h3>Что такое Backbone?</h3>

<p>Backbone.js это один из JavaScript Фреймворков для создания MVC-подобных веб-приложений. Для front-end'a я выбрал этот архитектурный Фреймворк, потому что он зрелый, относительно легкий, при этом легко тестируемый сторонними инструментами, такими как Jasmine или QUnit. Другие MVC фреймворки, с которыми вы возможно знакомы Ember.js (SproutCore 2.0), Spine, YUILibrary и JavaScriptMVC.</p>

<p>Backbone сопровождается несколькими разработчиками, наиболее известный из них: Jeremy Ashkenas, создатель CoffeeScript, Docco и Underscore.js. По убеждению Jeremy детальная документация определяет уровень комфорта в изучении, поэтому вы вряд ли столкнетесь с вопросами, не освещенными в официальной документации, либо с которыми нельзя справиться с помощью IRC канала #documentcloud. Я настоятельно рекомендую второй ресурс, если вам кажется, что вы застряли.</p>

<h3>Почему вам стоит рассмотреть возможность использовать это?</h3>

<p>Преимущества Backbone не зависящие от выбранной вами платформы, или устройства заключены в следующем:</p>

<ul>
<li>организация структуры вашего приложения</li>
<li>Упрощение сохранения информации на сервер. </li>
<li>Разделение DOM ваших страниц от данных</li>
<li>Модели данных, представления и роутеры в компактной форме.</li>
<li>Предоставляет синхронизацию между DOM, моделями и коллекциями моделей.</li>
</ul><h2>Основы</h2>

<p>В этой секции вы узнаете необходимый минимум о моделях, представлениях и роутерах Backbone, а также об использовании пространства имен для организации вашего кода. Этот документ можно считать заменой официальной документации, также он поможет детальнее рассмотреть основополагающие концепций поведения Backbone до началом создания приложений с использованием этого Фреймворка. </p>

<ul>
<li>Модели</li>
<li>Коллекции</li>
<li>Роутеры</li>
<li>Представления</li>
<li>Пространства имен</li>
</ul><h3><a name="models">Модели</a></h3>

<p>Модели Backbone содержат рабочий набор данных приложения, а также логику, связанную с этими данными. Например, мы можем использовать модель для представления понятия  объекта фотографии, включая ее атрибуты, такие как метки, заголовок и локация.</p>

<p>Модель создается расширением класса <code>Backbone.Model</code> следующим образом:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">src</span><span class="o">:</span> <span class="s1">'placeholder.jpg'</span><span class="p">,</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">'an image placeholder'</span><span class="p">,</span>
        <span class="nx">coordinates</span><span class="o">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">},</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"change:src"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">src</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"src"</span><span class="p">);</span> 
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Источник изображения изменен на:'</span> <span class="o">+</span> <span class="nx">src</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">},</span>
    <span class="nx">changeSrc</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">source</span> <span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span> <span class="nx">src</span><span class="o">:</span> <span class="nx">source</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">somePhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">({</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"test.jpg"</span><span class="p">,</span> <span class="nx">title</span><span class="o">:</span><span class="s2">"testing"</span><span class="p">});</span>
<span class="nx">somePhoto</span><span class="p">.</span><span class="nx">changeSrc</span><span class="p">(</span><span class="s2">"magic.jpg"</span><span class="p">);</span> <span class="c1">// Вызываем событие "change:src" и выводим сообщение об обновлений на консоль.</span>

</pre></div>

<h4>Инициализация</h4>

<p>Метод <code>initialize()</code> вызывается при создании экземпляра модели. Он опционален, но ниже будет показано, что его использование является хорошей практикой.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'эта модель была инициализирована'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="cm">/* Затем мы можем создать экземпляр нашей модели, как показано ниже:*/</span>
<span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">();</span>
</pre></div>

<h4>Геттеры и Сеттеры (Getters &amp; Setters)</h4>

<p><strong>Model.get()</strong></p>

<p><code>Model.get()</code> предоставляет простой способ получения атрибутов модели. Атрибуты, переданные в модель при создании ее экземпляра сразу являются доступными для извлечения.
Attributes which are passed through to the model on instantiation are instantly available for retrieval.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="s2">"My awesome photo"</span><span class="p">,</span> 
                          <span class="nx">src</span><span class="o">:</span><span class="s2">"boston.jpg"</span><span class="p">,</span> 
                          <span class="nx">location</span><span class="o">:</span> <span class="s2">"Boston"</span><span class="p">,</span> 
                          <span class="nx">tags</span><span class="o">:</span><span class="p">[</span><span class="s1">'the big game'</span><span class="p">,</span> <span class="s1">'vacation'</span><span class="p">]}),</span>

    <span class="nx">title</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"title"</span><span class="p">),</span> <span class="c1">//My awesome photo</span>
    <span class="nx">location</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"location"</span><span class="p">),</span> <span class="c1">//Boston</span>
    <span class="nx">tags</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"tags"</span><span class="p">),</span> <span class="c1">// ['the big game','vacation']</span>
    <span class="nx">photoSrc</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"src"</span><span class="p">);</span> <span class="c1">//boston.jpg</span>
</pre></div>

<p>Помимо этого, если вы хотите получить напрямую все атрибуты модели, это можно сделать следующим образом:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myAttributes</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">attributes</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myAttributes</span><span class="p">);</span>
</pre></div>

<p>Правильно устанавливать атрибуты модели, используя метод <code>Model.set()</code> или напрямую передавать их при создании экземпляра модели.</p>

<p>Доступ напрямую через <code>Model.attributes</code> в основном сбивает с толку. В место этого, если нужно читать или клонировать данные, используйте метод <code>Model.toJSON()</code> предназначенный для этого. Допустим вам надо получить копию атрибутов модели для JSON стрингификации (например, для предварительной сериализации перед их передачей в представление), это делается использованием <code>Model.toJSON()</code>:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myAttributes</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myAttributes</span><span class="p">);</span>
<span class="cm">/* this returns { title: "My awesome photo", </span>
<span class="cm">             src:"boston.jpg", </span>
<span class="cm">             location: "Boston", </span>
<span class="cm">             tags:['the big game', 'vacation']}*/</span>
</pre></div>

<h4>Model.set()</h4>

<p><code>Model.set()</code> дает вам возможность передать атрибуты в экземпляр модели. Атрибуты могут устанавливаться либо во время инициализации, либо в любое другое время после этого. Важно избегать попыток установки атрибутов напрямую, (к примеру, Model.caption = 'A new caption'). Backbone использует Model.set() чтобы быть в курсе и сообщать об изменениях в данных модели.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'эта модель была инициализирована'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="cm">/* Установка значений атрибутов при инициализации.*/</span>
<span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="s1">'My awesome photo'</span><span class="p">,</span> <span class="nx">location</span><span class="o">:</span> <span class="s1">'Boston'</span> <span class="p">});</span>

<span class="kd">var</span> <span class="nx">myPhoto2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">();</span>

<span class="cm">/*Установка атрибутов модели через Model.set()*/</span>
<span class="nx">myPhoto2</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span><span class="s1">'Vacation in Florida'</span><span class="p">,</span> <span class="nx">location</span><span class="o">:</span> <span class="s1">'Florida'</span> <span class="p">});</span>
</pre></div>

<p><strong>Значения по умолчанию</strong></p>

<p>Иногда вы можете захотеть, чтобы ваша модель имела значения по умолчанию (например, в случае, где пользователь может не предоставить полный набор данных). Их можно установить, используя свойство модели <code>defaults</code>.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">'Another photo!'</span><span class="p">,</span>
        <span class="nx">tags</span><span class="o">:</span>  <span class="p">[</span><span class="s1">'untagged'</span><span class="p">],</span>
        <span class="nx">location</span><span class="o">:</span> <span class="s1">'home'</span><span class="p">,</span>
        <span class="nx">src</span><span class="o">:</span> <span class="s1">'placeholder.jpg'</span>
    <span class="p">},</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">({</span> <span class="nx">location</span><span class="o">:</span> <span class="s2">"Boston"</span><span class="p">,</span> 
                          <span class="nx">tags</span><span class="o">:</span><span class="p">[</span><span class="s1">'the big game'</span><span class="p">,</span> <span class="s1">'vacation'</span><span class="p">]}),</span>
    <span class="nx">title</span>   <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"title"</span><span class="p">),</span> <span class="c1">//Another photo!</span>
    <span class="nx">location</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"location"</span><span class="p">),</span> <span class="c1">//Boston</span>
    <span class="nx">tags</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"tags"</span><span class="p">),</span> <span class="c1">// ['the big game','vacation']</span>
    <span class="nx">photoSrc</span> <span class="o">=</span> <span class="nx">myPhoto</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"src"</span><span class="p">);</span> <span class="c1">//placeholder.jpg</span>
</pre></div>

<p>**Слежение за изменения в модели **</p>

<p>В моделях Backbone все атрибуты вместе, либо каждый отдельный атрибут может иметь слушателя, который следит за изменениями их значений. Слушатели могут быть добавлены через функцию <code>initialize()</code>:</p>

<div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'change'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'значение модели было изменено'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>В следующем примере мы выводим сообщения всякий раз, когда определенные атрибуты (заголовок нашей модели Фото) изменяются. </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">'Another photo!'</span><span class="p">,</span>
        <span class="nx">tags</span><span class="o">:</span>  <span class="p">[</span><span class="s1">'untagged'</span><span class="p">],</span>
        <span class="nx">location</span><span class="o">:</span> <span class="s1">'home'</span><span class="p">,</span>
        <span class="nx">src</span><span class="o">:</span> <span class="s1">'placeholder.jpg'</span>
    <span class="p">},</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'эта модель была инициализирована'</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"change:title"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">title</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"title"</span><span class="p">);</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Мой заголовок был изменен на: "</span> <span class="o">+</span> <span class="nx">title</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">},</span>

    <span class="nx">setTitle</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newTitle</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">newTitle</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span><span class="s2">"Рыбалка на озере"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span><span class="s2">"fishing.jpg"</span><span class="p">});</span>
<span class="nx">myPhoto</span><span class="p">.</span><span class="nx">setTitle</span><span class="p">(</span><span class="s1">'Рыбалка на море'</span><span class="p">);</span> 
<span class="c1">//лог «Мой заголовок был изменен на: Рыбалка на море.»</span>
</pre></div>

<p><strong>Валидация</strong></p>

<p>Backbone поддерживает валидацию данных через функцию <code>Model.validate()</code>, которая позволяет проверить значения атрибутов во время их установки. </p>

<p>Функции валидации могут быть простыми или сложными при необходимости. Если представленные атрибуты являются валидными, то <code>.validate()</code> ничего не возвращает. В ином случае можно вернуть произвольную ошибку. </p>

<p>Общий пример валидации: </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Photo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">validate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">attribs</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">attribs</span><span class="p">.</span><span class="nx">src</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">){</span>
            <span class="k">return</span> <span class="s2">"Не забудьте указать расположение изображения!"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span>

    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'эта модель была инициализирована'</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"error"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">error</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">myPhoto</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Photo</span><span class="p">();</span>
<span class="nx">myPhoto</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="s2">"On the beach"</span> <span class="p">});</span>
<span class="c1">// лог «Не забудьте указать расположение изображения!»</span>
</pre></div>

<h3><a name="views">Представления</a></h3>

<p>Представления в Backbone не содержат разметку для вашего приложения, они в первую очередь содержат логику того, как модель будет показана пользователю. Это, как правило, достигается использованием JavaScript шаблонизаторов (Mustache, jQuery-tmpl и т.д.). Функция <code>render()</code> в представлении может быть привязана к событию модели <code>change()</code>, это позволит представлению быть всегда обновленным, без необходимости перезагрузки всей страницы.</p>

<h4>Создание нового представления</h4>

<p>Как и в предыдущем разделе, создание представлений относительно прямолинейно. Чтобы создать новое Представление нужно просто расширить <code>Backbone.View</code>. Подробнее я рассмотрю этот код ниже:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoSearch</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">el</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="s1">'#results'</span><span class="p">),</span>
    <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">){</span>
        <span class="kd">var</span> <span class="nx">compiled_template</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span> <span class="nx">$</span><span class="p">(</span><span class="s2">"#results-template"</span><span class="p">).</span><span class="nx">html</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">html</span><span class="p">(</span> <span class="nx">compiled_template</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">())</span> <span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// рекомендуется для поддержки цепочки вызовов.</span>
    <span class="p">},</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"submit #searchForm"</span><span class="o">:</span>  <span class="s2">"search"</span><span class="p">,</span>
        <span class="s2">"click .reset"</span><span class="o">:</span> <span class="s2">"reset"</span><span class="p">,</span>
        <span class="s2">"click .advanced"</span><span class="o">:</span> <span class="s2">"switchContext"</span>
    <span class="p">},</span>
    <span class="nx">search</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">){</span>
        <span class="c1">//выполняется при отправке формы '#searchForm'.</span>
    <span class="p">},</span>
    <span class="nx">reset</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">){</span>
        <span class="c1">//выполняется при клике на элемент с классом "reset".</span>
    <span class="p">},</span>
    <span class="nx">switchContext</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">){</span>
        <span class="c1">// выполняется при клике на элемент с классом "advanced".</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<h4>Что такое <code>el</code>?</h4>

<p><code>el</code> как правило, это ссылка на DOM элемент, и все представления должны иметь ее. Она нужна, чтобы вставлять все содержимое представления в определенном узле DOM на страницы, это делает более быстрым рендеринг страницы и позволяет минимизировать перерисовки выполняемые барузером.</p>

<p>Есть два способа добавлять DOM элементы представлений: либо элемент уже существуют на странице, либо это вновь созданный элемент для представления добавленный разработчиком.
Если элемент уже существует, вы можете назначить <code>el</code> либо CSS селектор, ссылающийся на этот элемент, либо прямую ссылку на DOM элемент.</p>

<div class="highlight"><pre><span class="nx">el</span><span class="o">:</span> <span class="s1">'#footer'</span><span class="p">,</span> 
<span class="c1">// ИЛИ</span>
<span class="nx">el</span><span class="o">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span> <span class="s1">'footer'</span> <span class="p">)</span>
</pre></div>

<p>Если вы хотите создать новый элемент для представления, установите в любой комбинации следующие свойства представления: <code>tagName</code>, <code>id</code> и <code>className</code>. Новый элемент будет создан для вас Фреймворком и ссылка на этот элемент будет доступна через свойство <code>el</code>.</p>

<div class="highlight"><pre><span class="nx">tagName</span><span class="o">:</span> <span class="s1">'p'</span><span class="p">,</span> <span class="c1">//обязательно, если не устанавливается, то по умолчанию будет 'div' </span>
<span class="nx">className</span><span class="o">:</span> <span class="s1">'container'</span><span class="p">,</span> <span class="c1">//опционально, вы можете назначить несколько классов разделяя их пробелом 'container homepage'</span>
<span class="nx">id</span><span class="o">:</span> <span class="s1">'header'</span><span class="p">,</span> <span class="c1">//опционально</span>
</pre></div>

<p>Код, размещенный выше, создает <code>DOMElement</code>, показанный ниже, но не добавляет его к DOM страницы.</p>

<div class="highlight"><pre><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">"header"</span> <span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;&lt;/p&gt;</span>
</pre></div>

<p><strong>Понимание <code>render()</code></strong></p>

<p>Не обязательная функция <code>render()</code> определяет логику рендеринга шаблона. Здесь мы будем использовать микро-шаблонизатор Underscore для примеров, но знайте, вы можете использовать любой другой шаблонизатор, который вы предпочитаете. </p>

<p>Метод <code>_.template</code> в Underscore компилирует JavaScript шаблон в функцию, которая может быть вызвана для рендеринга. В представлении, рассмотренном выше, я передаю шаблон с  id <code>results-template</code> в <code>_.template()</code> для его компиляции. Затем DOM элементу <code>el</code> в его html метод (пр. перевод.: предоставленный jQuery) я передаю скомпилированную функцию, которая в качестве параметров получает JSON версию связанной с представлением модели.</p>

<p>Presto! Шаблон заполняется данными модели, и на выходе вы получаете готовый html всего парой строк кода.</p>

<p>**Атрибут <code>events</code> **</p>

<p>Атрибут Backbone <code>events</code> позволяет добавлять слушателей событий различным селекторам либо напрямую к <code>el</code>, если селекторов нет. Привязка имеет следующую форму <code>{"имяСобытия селектор": "реагирующаяФункция"}</code> (пр. перевод.: возможно, это не удачный перевод <code>{"eventName selector": "callbackFunction"}</code>) и поддерживает различные типы событий, включая  <code>click</code>, <code>submit</code>, <code>mouseover</code>, <code>dblclick</code> и т.д. </p>

<p>Это не очевидно, но под капотом Backbone использует jQuery метод <code>.delegate()</code>, чтобы обеспечить оперативное делегирование событий, при этом немного расширяя этот метод, для того чтобы <code>this</code> всегда указывал на текущий объект представления. Единственное, что надо запомнит это то, что каждая строка описывающая привязку события должна иметь свою собственную реагирующую функцию доступную в области видимости данного представления. </p>

<h3><a name="collections">Коллекции</a></h3>

<p>Коллекции представляет собой набор Моделей и создается расширением <code>Backbone.Collection</code>.</p>

<p>Обычно, при создании коллекции одним из ее свойств указывают соответствующую модель, которые будет содержать эта коллекция, а также свойства, которые обязательны.</p>

<p>В следующем примере мы создаем коллекцию PhotoCollection, которая будет содержать наши модели Photo:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoCollection</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">model</span><span class="o">:</span> <span class="nx">Photo</span>
<span class="p">});</span>
</pre></div>

<p>** Геттеры и Сеттеры (Getters and Setters)**</p>

<p>Есть несколько различных способов получить модели из коллекции. Наиболее прямолинейный в использовании <code>Collection.get()</code> принимающий идентификатор (пр. перевод.: далее по тексту “id”) модели: </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">skiingEpicness</span> <span class="o">=</span> <span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>

<p>Иногда может понадобиться получить модель по клиентскому id. Клиентский id – это свойство, которое Backbone автоматически присваивает модели, которая еще не была сохранена. Вы можете получить клиентский id модели из ее свойства <code>.cid</code>.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">mySkiingCrash</span> <span class="o">=</span> <span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">getByCid</span><span class="p">(</span><span class="mi">456</span><span class="p">);</span>
</pre></div>

<p>Коллекции Backbone не имеют сеттеров, как таковых, но они поддерживают добавление моделей через <code>.add()</code> и их удаление через <code>.remove()</code>.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="s1">'my vacation'</span><span class="p">}),</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">({</span> <span class="nx">title</span><span class="o">:</span> <span class="s1">'my holiday'</span><span class="p">});</span>

<span class="kd">var</span> <span class="nx">photoCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PhotoCollection</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]);</span>
<span class="nx">photoCollection</span><span class="p">.</span><span class="nx">remove</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]);</span>
</pre></div>

<p><strong>Слушание событий</strong></p>

<p>Так как коллекция представляет собой группу элементов, мы можем слушать события <code>add</code> и <code>remove</code> при добавлении и удалении моделей в коллекции. Вот пример: </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">();</span>
<span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">photo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"I liked "</span> <span class="o">+</span> <span class="nx">photo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' its this one, right? '</span>  <span class="o">+</span> <span class="nx">photo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"src"</span><span class="p">));</span>
<span class="p">});</span>

<span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"My trip to Bali"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"bali-trip.jpg"</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"The flight home"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"long-flight-oofta.jpg"</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"Uploading pix"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"too-many-pics.jpg"</span><span class="p">}</span>
<span class="p">]);</span>
</pre></div>

<p>Вдобавок к этому мы можем привязаться к событию модели <code>change</code>, чтобы реагировать на изменения моделей в коллекции.</p>

<div class="highlight"><pre><span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s2">"change:title"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'произошли изменения “title” свойств моделей в этой коллекции.'</span><span class="p">);</span>    
<span class="p">});</span>
</pre></div>

<p><strong>Получение моделей с сервера</strong></p>

<p><code>Collections.fetch()</code> извлекает дефолтный набор моделей с сервера в формате JSON массива. По окончанию приема данных с сервера, текущее содержимое коллекции заменяется полученным массивом.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">PhotoCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">;</span>
<span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">url</span> <span class="o">=</span> <span class="s1">'/photos'</span><span class="p">;</span>
<span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">fetch</span><span class="p">();</span>
</pre></div>

<p>За кулисами Backbone всегда вызывает функцию <code>Backbone.sync</code> при чтении или сохранении моделей на сервер. При этом используется jQuery или Zepto реализация Ajax для выполнения RESTful запроса, однако данное поведение может быть изменено по вашему желанию.</p>

<p>Если вы хотите логировать каждый вызов <code>.sync()</code>  в примере выше, вы можете сделать следующее:</p>

<div class="highlight"><pre><span class="nx">Backbone</span><span class="p">.</span><span class="nx">sync</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Передано методу "</span> <span class="o">+</span> <span class="nx">method</span> <span class="o">+</span> <span class="s2">" с "</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>

<p>**Сброс/Обновление Коллекции **</p>

<p>Вместо добавления или удаления моделей индивидуально, возможно вам понадобиться обновить всю коллекцию сразу. <code>Collection.reset()</code> позволяет заменить все модели коллекции, как показано ниже:   </p>

<div class="highlight"><pre><span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">reset</span><span class="p">([</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"My trip to Scotland"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"scotland-trip.jpg"</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"The flight from Scotland"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"long-flight.jpg"</span><span class="p">},</span>
  <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"Latest snap of lock-ness"</span><span class="p">,</span> <span class="nx">src</span><span class="o">:</span> <span class="s2">"lockness.jpg"</span><span class="p">}</span>
<span class="p">]);</span>
</pre></div>

<h3>Вспомогательные функции Underscore</h3>

<p>Так как Backbone зависит от Underscore (<i>пр. перевод.: советую взглянуть на</i> <a href="https://github.com/bestiejs/lodash">Lo-Dash</a>), мы можем использовать множество полезных утилит, предлагаемых этой библиотекой. Ниже приведен пример того, как можно сортировать коллекцию моделей по определенному атрибуту модели, используя для этого метод Underscore <code>sortBy()</code>.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">sortedByAlphabet</span> <span class="o">=</span> <span class="nx">PhotoCollection</span><span class="p">.</span><span class="nx">sortBy</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">photo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">photo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"title"</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>

<p>Полный список того, что может делать Underscore выходит за рамки данного руководства, вы можете прочитать об этом самостоятельно в <a href="http://underscorejs.ru/">документации</a>.</p>

<h3><a name="routers">Маршрутизаторы</a></h3>

<p><i>Примечание переводчика: Здесь и далее по тексту Router переводится как Маршрутизатор, route как маршрут</i></p>

<p>Маршрутизаторы в Backbone призваны помочь в управлении состоянием приложения и привязать переходы по URL’ам к событиям приложения. Они активируют использование хэш-тегов с фрагментами URL, или используют pushState и History API браузера. Небольшой пример маршрутов приведен ниже:</p>

<div class="highlight"><pre>http://unicorns.com/#whatsup
http://unicorns.com/#search/seasonal-horns/page2
</pre></div>

<p>Примечание: В приложении, как правило, хотя бы один маршрутизатор является отображением URL’a на функцию, которая определяет реакцию приложения на переход пользователя по данному URL. Эта взаимосвязь определяется следующим образом:    </p>

<div class="highlight"><pre><span class="s2">"route"</span> <span class="o">:</span> <span class="s2">"mappedFunction"</span>
</pre></div>

<p>Давайте создадим наш первый контроллер расширением <code>Backbone.Router</code>. В рамках данного руководства мы будем продолжать создание нашего обучающего проекта фото галереи, для которой нам необходим GalleryRouter.</p>

<p>Обратите внимание на комментарии в коде ниже, потому что в них содержится следующая часть данного урока.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">GalleryRouter</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="cm">/* Определяем маршруты и привязанные к ним функции */</span>
    <span class="nx">routes</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"about"</span> <span class="o">:</span> <span class="s2">"showAbout"</span><span class="p">,</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#about */</span>

        <span class="s2">"photos/:id"</span> <span class="o">:</span> <span class="s2">"getPhoto"</span><span class="p">,</span>
        <span class="cm">/* Пример использования переменной ":параметр", которая будет </span>
<span class="cm">           соответствовать определенному компоненту между парой слешей URL. */</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#photos/5 */</span>

        <span class="s2">"search/:query"</span> <span class="o">:</span> <span class="s2">"searchPhotos"</span>
        <span class="cm">/* Также можно привязывать множество маршрутов к одной и той же функции,</span>
<span class="cm">           в данном случае к searchPhotos(). */</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#search/lolcats */</span>

        <span class="s2">"search/:query/p:page"</span> <span class="o">:</span> <span class="s2">"searchPhotos"</span><span class="p">,</span>
        <span class="cm">/* Функция получит необязательный номер страницы, если он был передан.</span>
<span class="cm">           Как видите, URL’ы могут содержать много ":параметр"ов, столько сколько нам нужно. */</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#search/lolcats/p1 */</span>

        <span class="s2">"photos/:id/download/*imagePath"</span> <span class="o">:</span> <span class="s2">"downloadPhoto"</span><span class="p">,</span>
        <span class="cm">/* В этом примере используется знак *, он позволяет ":параметр"у соответствовать </span>
<span class="cm">           любому количеству компонентов URL. */</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#photos/5/download/files/lolcat-car.jpg*/</span>

        <span class="cm">/* Если вы хотите использовать знак * для маршрутизации по умолчанию, уместно</span>
<span class="cm">           будет помещать этот параметр в конце, иначе вам придется применять</span>
<span class="cm">           к полученному фрагменту регулярные выражения */</span> 

        <span class="s2">"*other"</span>    <span class="o">:</span> <span class="s2">"defaultRoute"</span>
        <span class="cm">/* Этот маршрут по умолчанию также использует знак *. Этот шаблон маршрута</span>
<span class="cm">           по умолчанию для всех URL’ов, которые либо не обрабатываются маршрутизаторами выше,</span>
<span class="cm">           либо для ошибочного ввода от пользователя. */</span>
        <span class="cm">/* Пример использования: http://unicorns.com/#anything */</span>

    <span class="p">},</span>

    <span class="nx">showAbout</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="p">},</span>

    <span class="nx">getPhoto</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
        <span class="cm">/* </span>
<span class="cm">        Обратите внимание, что id параметр, совпавший в маршруте передается в функцию.</span>
<span class="cm">        */</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Вы пытаетесь получить фото "</span> <span class="o">+</span> <span class="nx">id</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="nx">searchPhotos</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">page</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Страница номер "</span> <span class="o">+</span> <span class="nx">page</span> <span class="o">+</span> <span class="s2">" результатов для "</span> <span class="o">+</span> <span class="nx">query</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="nx">downloadPhoto</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">path</span><span class="p">){</span>
    <span class="p">},</span>

    <span class="nx">defaultRoute</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">other</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Ошибка. Попытка получить:"</span> <span class="o">+</span> <span class="nx">other</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="cm">/* Когда Маршрутизатор готов, не забудьте создать его экземпляр. */</span>

<span class="kd">var</span> <span class="nx">myGalleryRouter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GalleryRouter</span><span class="p">();</span>
</pre></div>

<p>С версии Backbone 0.5+ появилась поддержка pushState из HTML5 через <code>window.history.pushState</code>. Это позволяет вам создавать маршруты на подобии этого <a href="http://www.scriptjunkie.com/just/an/example">http://www.scriptjunkie.com/just/an/example</a>. В браузерах не поддерживающих pushState будет наблюдаться падение производительности. В рамках этого руководства мы будем использовать метод использующий хэш-теги.</p>

<h4>Backbone.history</h4>

<p>Следующим шагом нам надо инициализировать <code>Backbone.history</code> для обработки <code>hashchange</code> (пр. перевод.: для обработки смены хэша в строке навигации) в нашем приложении. Это позволит автоматически обрабатывать маршруты, определенные в  нашем приложении и вызывать их функции (callbacks) когда маршрут был посещен.</p>

<p>Метод <code>Backbone.history.start()</code> просто сообщает Backbone, что можно начинать мониторить все <code>hashchange</code> события: </p>

<div class="highlight"><pre><span class="nx">Backbone</span><span class="p">.</span><span class="nx">history</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
<span class="nx">Router</span><span class="p">.</span><span class="nx">navigate</span><span class="p">();</span>
</pre></div>

<p>Если вы хотите сохранять состояние URL приложения в определенный момент, вы можете использовать для этого метод <code>.navigate()</code>. Фрагмент URL будет обновляться без необходимости вызова события <code>hashchange</code>:</p>

<div class="highlight"><pre><span class="cm">/* Допустим, мы хотим иметь конкретный фрагмент в URL, когда пользователь изменяет масштаб фотографии. */</span>
<span class="nx">zoomPhoto</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">factor</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">zoom</span><span class="p">(</span><span class="nx">factor</span><span class="p">);</span> <span class="c1">//представим, что тут увеличивается изображение  </span>
    <span class="k">this</span><span class="p">.</span><span class="nx">navigate</span><span class="p">(</span><span class="s2">"zoom/"</span> <span class="o">+</span> <span class="nx">factor</span><span class="p">);</span> <span class="c1">// обновит для нас фрагмент URL, но не вызывает маршрут. </span>
<span class="p">}</span>
</pre></div>

<p>Также <code>Router.navigate()</code> может вызывать маршрут, при обновлении фрагмета URL.</p>

<div class="highlight"><pre><span class="nx">zoomPhoto</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">factor</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">zoom</span><span class="p">(</span><span class="nx">factor</span><span class="p">);</span> <span class="c1">//представим, что тут увеличивается изображение </span>
    <span class="k">this</span><span class="p">.</span><span class="nx">navigate</span><span class="p">(</span><span class="s2">"zoom/"</span> <span class="o">+</span> <span class="nx">factor</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// обновит для нас фрагмент URL, и вызовет маршрут. </span>
<span class="p">}</span>
</pre></div>

<h3><a name="namespacing">Пространства имен</a></h3>

<p>При изучении Backbone важным понятием является пространство имен, однако, многие руководства забывают об этом. Если вы имеете практический опыт в области пространства имен JavaScript, то следующая секция добавит несколько полезных советов о том, как применить эти знания к специфике Backbone.  Так же в этой секции я буду объяснять это понятие и для новичков. </p>

<h4>В чем смысл пространства имен?</h4>

<p>Основная идея пространства имен в том, чтобы избежать коллизии имен переменных и объектов в глобальном пространстве имен. Это важно, и является наилучшей защитой от поломки вашего кода, при появлении на странице других скриптов, с такими же именами переменных, как и в вашем коде. И как хороший 'житель' глобального пространства имен, важно, чтобы вы делали максимум для предотвращения поломки скриптов других разработчиков. </p>

<p>JavaScript не имеет встроенной поддержки пространства имен, как в других языках, зато имеет замыкания, которые помогут нам достичь схожего эффекта. </p>

<p>В этой секции мы рассмотрим короткие примеры организации пространства имен ваших моделей, представлений, маршрутизаторов и других компонентов. Шаблоны, которые мы рассмотрим:</p>

<ul>
<li>Единственная глобальная переменная </li>
<li>Объектные литералы </li>
<li>Вложенные пространства имен </li>
</ul><p><strong>Единственная глобальная переменная</strong></p>

<p>Один из популярных шаблонов пространства имен в JavaScript - это единственная глобальная переменная, как объект доступа к переменным. Далее скелет реализации, в котором мы возвращаем объект с функциями и свойствами:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myApplication</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// ...</span>
    <span class="p">},</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">})();</span>
</pre></div>

<p>Вы могли видеть эту технику раньше. Пример с Backbone:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myViews</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">PhotoView</span><span class="o">:</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span> <span class="p">..</span> <span class="p">}),</span>
        <span class="nx">GalleryView</span><span class="o">:</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span> <span class="p">..</span> <span class="p">}),</span>
        <span class="nx">AboutView</span><span class="o">:</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span> <span class="p">..</span> <span class="p">});</span>
        <span class="c1">//и т.д.</span>
    <span class="p">};</span>
<span class="p">})();</span>
</pre></div>

<p>Здесь мы возвращаем набор представлений, но этот же метод можно использовать для всей коллекции моделей, представлений и маршрутизаторов, в зависимости от структуры вашего приложения. Это работает для определенных ситуаций, но самая большая проблема с шаблоном единственной глобальной переменной заключена в необходимости того, чтобы никто кроме вас не использовал имя этой глобальной переменной в пределах данной страницы.</p>

<p>Одно из решений данной проблемы, предложенное Peter Michaux, это использовать префиксы пространства имен. В основе своей идея очень простая, использовать общие префиксы имен (в данном примере <code>myApplication_</code>), и после них указывать любые названия методов, переменных и других объектов.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myApplication_photoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({}),</span>
<span class="nx">myApplication_galleryView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
</pre></div>

<p>Это эффективно, потому что вероятность существования идентичных имен в глобальном пространстве будет очень мала, но помните, объекты с уникальными именами дают тот же эффект. Недостатком этого шаблона является вероятность получить огромное количество глобальных объектов в результате роста вашего приложения. </p>

<p>Больше информации о том, как Peter представляет себе шаблоне единственной глобальной переменной, читайте в его <a href="http://michaux.ca/articles/javascript-namespacing">прекрасной статье на эту тему</a>.</p>

<p>Примечание: В дикой природе есть множество реализаций шаблона единственной глобальной переменной, но испробовав множество из них, я чувствую, что для Backbone лучше всего подходи использование глобального префикса.</p>

<p><strong>Объектные литералы</strong></p>

<p>Объектные литералы имеют преимущество, не загрязняя глобальное пространство имен, они помогают логически организовать код и параметры. Они полезны, если вы хотите создать легко читаемую структуру, которую можно расширять глубокой вложенностью. В отличии от простых глобальных переменных, для Объектных Литералов часто реализуют проверку на существование переменной, это помогает уменьшить вероятность коллизий. </p>

<p>Пример, демонстрирующий два способа проверки пространства имен на существование переменной, перед ее определением. Я обычно использую вариант 2.</p>

<div class="highlight"><pre><span class="cm">/* Проверка существования myApplication не выполняется */</span>
<span class="kd">var</span> <span class="nx">myApplication</span> <span class="o">=</span> <span class="p">{};</span>

<span class="cm">/*</span>
<span class="cm">Выполняем проверку. Если переменная уже определена, используем ее.</span>
<span class="cm">Вариант 1:   if(!myApplication) myApplication = {};</span>
<span class="cm">Вариант 2:   var myApplication = myApplication || {};</span>

<span class="cm">Затем мы можем добавить в наш объект возможность сохранения моделей, представлений и коллекций (на самом деле, любых данных):</span>
<span class="cm">*/</span>

<span class="kd">var</span> <span class="nx">myApplication</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">models</span> <span class="o">:</span> <span class="p">{},</span>
    <span class="nx">views</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">pages</span> <span class="o">:</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="nx">collections</span> <span class="o">:</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>

<p>Как вариант, можно добавлять свойства глобальному пространству имен (как в этом примере с представлениями):</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myGalleryViews</span> <span class="o">=</span> <span class="nx">myGalleryViews</span> <span class="o">||</span> <span class="p">{};</span>
<span class="nx">myGalleryViews</span><span class="p">.</span><span class="nx">photoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
<span class="nx">myGalleryViews</span><span class="p">.</span><span class="nx">galleryView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
</pre></div>

<p>Преимущества этого шаблона дают вам возможность легко инкапсулировать все ваши модели, представления, маршрутизаторы и т.д, это позволит четко отделить их и будет являться солидной основой для расширения вашего кода.  </p>

<p>Этот шаблон хорош многим. Его выбор часто является хорошей идеей для отделения конфигурации по умолчанию вашего приложения в отдельной области, которую легко модифицировать без необходимости поиска отдельных переменных по всему коду. Потенциальный пример объектного литерала, в котором сохраняется конфигурация приложения: </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">language</span><span class="o">:</span> <span class="s1">'english'</span><span class="p">,</span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">enableGeolocation</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">enableSharing</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nx">maxPhotos</span><span class="o">:</span> <span class="mi">20</span>
    <span class="p">},</span>
    <span class="nx">theme</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">skin</span><span class="o">:</span> <span class="s1">'a'</span><span class="p">,</span>
        <span class="nx">toolbars</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">index</span><span class="o">:</span> <span class="s1">'ui-navigation-toolbar'</span><span class="p">,</span>
            <span class="nx">pages</span><span class="o">:</span> <span class="s1">'ui-custom-toolbar'</span>    
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Заметьте, на самом деле совсем немного синтаксических различий между шаблоном Объектного Литерала и стандартом хранения данных JSON. Если по каким либо причинам вы хотите использовать JSON для сохранения конфигурации (например для простоты хранения при отправке бэк-энду), не стесняйтесь.
<i>пр. перевод.: Объектный литерал (Object Literal), сам по себе не является шаблоном, это синтаксическая конструкция языка программирования</i></p>

<p>Больше о шаблоне Объектного Литерала, рекомендую почитать <a href="http://blog.rebeccamurphey.com/2009/10/15/using-objects-to-organize-your-code">прекрасную статью</a> Rebecca Murphey на эту тему.</p>

<p><strong>Вложенные пространства имен</strong></p>

<p>Расширение шаблона Объектного Литерала - вложенные пространства имен. Это еще один распространенный шаблон, предлагает низкий вероятность коллизии, основываясь на том факте, что даже если пространство имен верхнего уровня уже существует, оно, вряд ли имеет туже структуру дочерних объектов. Для примера YUI от Yahoo активно использует шаблон вложенных объектов пространства имен: </p>

<div class="highlight"><pre><span class="nx">YAHOO</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">Dom</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="s1">'test'</span><span class="p">);</span>
</pre></div>

<p>YUI от Yahoo использует шаблон вложенных объектов пространства имен постоянно, и даже DocumentCloud (создатель Backbone) использует шаблон вложенных пространств имен в своих основных приложения. Простая реализация вложенных пространств имен с использованием Backbone может выглядеть так:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">galleryApp</span> <span class="o">=</span>  <span class="nx">galleryApp</span> <span class="o">||</span> <span class="p">{};</span>

<span class="cm">/*производим простую проверку вложенных дочерних объектов*/</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">routers</span> <span class="o">=</span> <span class="nx">galleryApp</span><span class="p">.</span><span class="nx">routers</span> <span class="o">||</span> <span class="p">{};</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span> <span class="o">||</span> <span class="p">{};</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">special</span> <span class="o">=</span> <span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">special</span> <span class="o">||</span> <span class="p">{};</span>

<span class="cm">/*маршрутизаторы*/</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">routers</span><span class="p">.</span><span class="nx">Workspace</span>   <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span> 
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">routers</span><span class="p">.</span><span class="nx">PhotoSearch</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span> 

<span class="cm">/*модели*/</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">Photo</span>   <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">Comment</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span> 

<span class="cm">/*специализированные модели*/</span>
<span class="nx">galleryApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">special</span><span class="p">.</span><span class="nx">Admin</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
</pre></div>

<p>Это читаемая и чистая организация является безопасной реализацией пространства имен для вашего Backbone приложения. Возможно это знакомо вам, если вы использовали другие языки программирования. </p>

<p>Единственная оговорка, этот подход заставляет JavaScript движок вашего браузера сначала определить местонахождение объекта galleryApp, и потом копать вглубь до тех пор, пока он не доберется до функции, которые вызываете. В виду этого разработчики, в частности Юрий Зайцев (kangax), провели тестирование производительности шаблона c одним объектом пространства имен против "вложенного" подхода, и получили незначительные различия.</p>

<p><strong>Рекомендации</strong></p>

<p>Из обзора шаблонов пространства имен я предпочитаю для написания Backbone приложений использовать вложенные объекты пространств имен, с шаблоном Объектного Литерала.</p>

<p>Единственная глобальная переменная может работать прекрасно для относительно простых приложении, однако большая кодовая база требует глубокой вложенности подпространств имен в основной области для реализации одновременно читаемого и расширяемого решения задачи. Я чувствую, что такой подход решает обе задачи и является хорошим выбором для разработки с использованием Backbone.</p>

<h3><a name="additional-tips">Дополнительные советы</a></h3>

<h4>Автоматизированный Backbone Скаффолдинг</h4>

<p>Скаффолдинг может помочь в сокращении времени, необходимом для рождения нового проекта, путем создания базовых, необходимых приложению, файлов в автоматическом режиме. Если вам нравится идея автоматизированного MVC скаффолдинга с использованием Backbone, я счастлив порекомендовать инструмент под названием <a href="https://github.com/brunch/brunch">Brunch</a>.</p>

<p>Он очень хорошо работает с Backbone, Underscore, jQuery, и CoffeeScript, и даже используется такими компаниями как Red Bull и Jim Bean. Возможно, вам придется обновить некоторые зависимости (новейшую версию jQuery или Zepto) при использовании этого инструмента, в остальном он достаточно стабилен, чтобы использовать его прямо из коробки. </p>

<p>Brunch можно получить, просто установив его через менеджер пакетов nodejs. Если ваш любимый редактор это Vim или Textmate, вы будете приятно удивлены тем, что для них доступен плагин Brunch. </p>

<h4>Есть ли ограничение на количество маршрутизаторов?</h4>

<p>Andrew de Andrade отметил, что DocumentCloud для большинства своих проектов обычно использует только один маршрутизатор. Вам, скорее всего не потребуется в ваших приложениях использовать больше одного, двух маршрутизаторов, все маршруты могут быть аккуратно организованны в одном контроллере. </p>

<h4>Backbone мало для вашего приложения?</h4>

<p>Если вы не уверены, действительно ли ваше приложение слишком сложное для использования Backbone, я рекомендую прочитать мою статью о создании больших и масштабируемых приложений на jQuery и JavaScript, или посмотреть мои слайды о вариантах клиентской MVC архитектуры. В обоих вариантах я рассматриваю альтернативные решения, и излагаю свои мысли о пригодности текущего MVC решения для разработки масштабируемых приложений. </p>

<p>Backbone можно использовать для создания как простых, так и сложных приложений, это демонстрирует большое количество примеров Ashkenas, приведенных в Backbone документации. Как и в любом другом MVC Фреймворке, важно уделить время планированию, какие именно модели и представления вам реально необходимы. Погружение в разработку без выполнения этих шагов может привести к спагетти коду, или к полному рефакторингу в будущем, лучше избегать этих последствий везде, где это возможно.</p>

<p>В конце концов, ключ к созданию больших приложений, стараться изначально не строить больших приложений. Если вы обнаружите, что Backbone все-таки вам не вписывается в ваши требования, я в первую очередь рекомендую посмотреть на  JavaScriptMVC или SproutCore, они оба умеют из коробки немного больше, чем Backbone. Dojo и Dojo Mobile также представлять интерес, так как они использовались некоторыми разработчиками для создания достаточно сложных приложений. </p>

<h2><a name="advanced">Расширенная часть</a></h2>

<h2><a name="restful">Создание RESTful приложений с Backbone</a></h2>

<p>В этой части книги мы переходим к созданию RESTful приложения с использованием Backbone.js и набора современных технологий. Когда взаимодействие с бэк-эндом выполнено на чистом RESTful API, такие операции как получение (GET), создание (POST), обновление (PUT) и удаление (DELETE) моделей выполняются через API Моделей Backbone. Эти API интуитивно понятны, поэтому, реальное изменения хранилища данных с локального (к примеру, localStorage) на базу данных/noSQL хранилище намного проще, чем вы могли подумать.</p>

<h2><a name="stack1">Набор 1: Используем Node.js, Express, Mongoose и MongoDB</a></h2>

<p>В первом наборе мы будем рассматривать:</p>

<ul>
<li><a href="nodejs.org">Node.js</a></li>
<li><a href="http://expressjs.com/">Express</a></li>
<li><a href="http://mongoosejs.com/">Mongoose</a></li>
<li>и <a href="http://www.mongodb.org/">MongoDB</a>
</li>
</ul><p>c <a href="http://jade-lang.com/">Jade</a> опционально, как движок шаблонизатора (view/templating engine).</p>

<p><i>пр. перевод.: советую заглянуть <a href="http://jsman.ru/">сюда</a></i></p>

<h3>Обзор набора</h3>

<p>Не секрет, что node.js это событийно-ориентированная платформа (созданная с исползованием <a href="http://code.google.com/apis/v8/design.html">V8</a>), разработанная для написания быстрых и расширяемых сетевых приложений. Она легкая, эффективная и отлично подходит для создания приложений реального времени, работающего с большими объемами данных.</p>

<p>Express это веб-фреймворк для node.js, вдохновленный <a href="http://www.sinatrarb.com/">Sinatra</a>. Он включает множество полезных возможностей, таких как интуитивные представления, надежную маршрутизацию и фокусируется на производительности.</p>

<p>Следующие по списку MongoDB и Mongoose. MongoDB - документо-ориентированная база данных с открытым исходным кодом, разработанная быть расширяемой и гибкой. В <a href="http://ru.wikipedia.org/wiki/NoSQL">noSQL</a> базах дынных, вместо того чтобы сохранять информацию в таблицы и строки (то, что мы очень привыкли делать в реляционных базах данных), в Mongo для ее хранения мы будем использовать JSON-подобные документы с использованием динамических схем. Одна из целей Mongo в том, чтобы преодолеть разрыв между хранилищами типа ключ-значение (скорость, масштабируемость) и реляционными базами данных (богатый функционал). </p>

<p>Mongoose - это JavaScript библиотека упрощающая работу с Mongo. Подобно Express, она разрабатывалась для работы в окружении node.js и пытается решить некоторые сложности, связанные с асинхронным сохранением данных, предлагая более удобное API. В нее добавлена поддержка цепочной функциональности <i>(пр. превод.: chaining features)</i>, позволяющей более выразительно работать с нашими данными. </p>

<p>Jade – это шаблонизатор, созданный под впечатлением от Haml (которые мы будем рассматривать позже). Он реализован с использованием JavaScript (также работает с node). Дополнительно поддерживается Express из коробки и имеет ряд полезного функционала, включая поддержку примесей, включений, кэширования, наследования шаблонов и еще много чего. Такие абстракции как Jade не будут использоваться на протяжении всей нашей практики, мы рассмотрим работу, как с ними, так и без них. </p>

<h3>Практика</h3>

<p>Для этой практической работы мы в очередной раз займемся улучшением популярного Backbone приложения Todo. Мы изменим это приложение таким образом, чтобы оно сохраняло список дел не в localStorage, а в документо-ориентированном хранилище MongoDB. Код этой практической работы можно посмотреть по следующей ссылке: <a href="https://github.com/addyosmani/backbone-boilerplates/tree/master/option2">https://github.com/addyosmani/backbone-boilerplates/tree/master/option2</a></p>

<p><strong>app.js</strong></p>

<p>(<a href="https://github.com/addyosmani/backbone-boilerplates/blob/master/option2/app.js">Исходный код</a>)</p>

<p>Первым делом надо подключить необходимые нашему приложению зависимости. Это Express, Mongoose и Path (модуль, содержащий утилиты для работы с путями файловой системы)</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">application_root</span> <span class="o">=</span> <span class="nx">__dirname</span><span class="p">,</span>
  <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"express"</span><span class="p">),</span>
  <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"path"</span><span class="p">),</span>
  <span class="nx">mongoose</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'mongoose'</span><span class="p">);</span>
</pre></div>

<p>Далее создаем экземпляр сервера Express `express.createServer, это простой способ создания экземпляра express.HTTPServer, который мы будем использовать для передачи наших маршрутов. <i>пр. переводчика: для express версии 3.0 устарело</i></p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">.</span><span class="nx">createServer</span><span class="p">();</span>
</pre></div>

<p>After this, connect Mongoose up to a database (in our case, localhost should suffice). Should you require the ability to pass in authentication information, here's a sample containing all of the supported URL parameters: <code>mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></p>

<div class="highlight"><pre><span class="nx">mongoose</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="s1">'mongodb://localhost/my_database'</span><span class="p">);</span>
</pre></div>

<p>A Mongoose model for any Todo item can now be easily defined by passing a schema instance to <code>mongoose.model</code>. In our case the schema covers a Todo item's <code>text</code> content, its <code>done</code> state and <code>order</code> position in the overall Todo list.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Todo</span> <span class="o">=</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">model</span><span class="p">(</span><span class="s1">'Todo'</span><span class="p">,</span> <span class="k">new</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">Schema</span><span class="p">({</span>
  <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="nx">done</span><span class="o">:</span> <span class="nb">Boolean</span><span class="p">,</span>
  <span class="nx">order</span><span class="o">:</span> <span class="nb">Number</span>
<span class="p">}));</span>
</pre></div>

<p>The <code>configure()</code> methods allows us to setup what we need for the current environment with our Express server. Note that lower down in the configuration are two view/view related lines. The last one explicitly sets the viewing/templating engine to be used as Jade <code>app.set('view engine', 'jade')</code>. We can avoid these if we wish to use plain HTML/JS for our templates instead.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="c1">// the bodyParser middleware parses JSON request bodies</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">methodOverride</span><span class="p">());</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nx">router</span><span class="p">);</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">application_root</span><span class="p">,</span> <span class="s2">"public"</span><span class="p">)));</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">({</span> <span class="nx">dumpExceptions</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">showStack</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}));</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'views'</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">application_root</span><span class="p">,</span> <span class="s2">"views"</span><span class="p">));</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'view engine'</span><span class="p">,</span> <span class="s1">'jade'</span><span class="p">)</span>
<span class="p">});</span>

</pre></div>

<p>Should you prefer to switch out Jade for an alternative view engine, this can be done fairly trivially. See the section under 'Templating' here:
<a href="https://github.com/joyent/node/wiki/modules">https://github.com/joyent/node/wiki/modules</a>. For example, to switch to EJS, you would simply write <code>app.set('view engine', 'ejs')</code></p>

<p>Express makes use of common HTTP verbs (get, put, post etc.) to provide easy to use, expressive routing API based on CRUD (Create, Read, Update and Delete). Below for example, we can define what happens when the browser requests the root '/'. As a trivial route in this application, it doesn't do anything particularly exciting, however getters typically read or retrieve data.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Hello World'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>Onto something a little more useful and in our next route, navigating to '/todo' will actually render our Jade view 'todo.jade', as seen in the callback. Additional configuration values can be passed as the second parameter, such as the custom title specified below.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/todo'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'todo'</span><span class="p">,</span> <span class="p">{</span><span class="nx">title</span><span class="o">:</span> <span class="s2">"Our sample application"</span><span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>Next, we can see the first of our '/api/' routes. </p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/api/todos'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">Todo</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">todos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">todos</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>The callback to our next route supports querying for todos based on a specific ID. The route string itself (once compiled) will be converted from '/api/todos/:id' to a regular expression. As you might have guessed, this is a hint that routes can also be regular expression literals if we wished to do something more complex.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/api/todos/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">Todo</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">todo</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>Similarly, we want to support updating todos based on a specific ID as well. The following allows us to query a todo by ID and then update the values of it's three attributes (text, done, order) easily. </p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">'/api/todos/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">Todo</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">todo</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">text</span><span class="p">;</span>
    <span class="nx">todo</span><span class="p">.</span><span class="nx">done</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">done</span><span class="p">;</span>
    <span class="nx">todo</span><span class="p">.</span><span class="nx">order</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">order</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"updated"</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">todo</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>We've so far covered requesting todos and updating them, but a core part of the application requires us to insert (or add) new todos to our data-store. Below we can create new <code>Todo</code> models and simply save them.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">'/api/todos'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">todo</span><span class="p">;</span>
  <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">({</span>
    <span class="nx">text</span><span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span>
    <span class="nx">done</span><span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span>
    <span class="nx">order</span><span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">order</span>
  <span class="p">});</span>
  <span class="nx">todo</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"created"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">todo</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>We of course also want to support deleting todos (e.g if a todo has been 'cleared', it should be deleted). This also works based on a specific todo ID.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">'/api/todos/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">Todo</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"removed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>Finally, this last line is to ensure we're only listening on the port app.js is running.</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</pre></div>

<p><strong>script.js - updating our Backbone.js app</strong></p>

<p>In the <code>/public/js</code> folder of options 1 (HTML templates) and 2 (Jade) for the practical, you'll find a version of the Backbone Todo app originally by Jerome Gravel-Niquet. Let's pay attention to <a href="https://github.com/addyosmani/backbone-boilerplates/blob/master/option2/public/js/script.js">script.js</a>. In order to change the application to work with our new back-end, we'll need to make some very minor changes to this.</p>

<p>Reviewing <code>window.TodoList</code> (a Backbone Collection), you'll notice that it has a property called <code>localStorage</code>, which uses the Backbone <a href="https://github.com/jeromegn/Backbone.localStorage">localStorage</a> adapter in order to facilitate storing data using the browser's localStorage features.</p>

<div class="highlight"><pre><span class="nb">window</span><span class="p">.</span><span class="nx">TodoList</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Reference to this collection's model.</span>
    <span class="nx">model</span><span class="o">:</span> <span class="nx">Todo</span><span class="p">,</span>

    <span class="c1">// Save all of the todo items under the `"todos"` namespace.</span>
    <span class="c1">// Typically, this should be a unique name within your application</span>
    <span class="nx">localStorage</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Store</span><span class="p">(</span><span class="s2">"todos"</span><span class="p">),</span>
</pre></div>

<p>In order to switch it over to our RESTful backend, we're going to make use of the <code>url</code> property or function on a collection to reference its location on the server. Models inside of a collection then use <code>url</code> to construct URLs of their own. As all of the CRUD for our RESTful API works on the base route '/api/todos', this is the value we set <code>url</code> to.</p>

<div class="highlight"><pre>    <span class="c1">// localStorage: new Store("todos"),</span>
    <span class="nx">url</span><span class="o">:</span> <span class="s1">'/api/todos'</span><span class="p">,</span>
</pre></div>

<p>This is the only change necessary to our existing Backbone application in order to get things working. Pretty easy, right?</p>

<p><strong>todo.jade</strong></p>

<p>The Jade templates for our application cover declarative markup for both the index (layout.jade) of the application and the main Todo container (todo.jade). It also covers the script-tag templates used for rendering each new Todo item that's added.</p>

<pre>
// Todo App Interface

#todoapp
  .title
    h1 Todos
  .content
    #create-todo
      input#new-todo(placeholder="What needs to be done?", type="text")
      span.ui-tooltip-top(style="display:none;") Press Enter to save this task
    #todos
      ul#todo-list
    #todo-stats


// Templates
script#item-template(type="text/template")
  &lt;div class="todo &lt;%= done ? 'done' : '' %&gt;"&gt;
  .display
    &lt;input class="check" type="checkbox" &lt;%= done ? 'checked="checked"' : '' %&gt; /&gt;
    .todo-text 
    span#todo-destroy
  .edit
    input.todo-input(type="text", "value"="")
  &lt;/div&gt;

script#stats-template(type="text/template")
  &lt;% if (total) { %&gt;
  span.todo-count
    span.number &lt;%= remaining %&gt; 
    span.word &lt;%= remaining == 1 ? 'item' : 'items' %&gt;
    |  left.
  &lt;% } %&gt;
  &lt;% if (done) { %&gt;
  span.todo-clear
    a(href="#")
      |  Clear
      span.number-done &lt;%= done %&gt;
      |  completed
      span.word-done &lt;%= done == 1 ? 'item' : 'items' %&gt;
  &lt;% } %&gt;
</pre>

<p><strong>layout.jade</strong></p>

<pre>
!!! 5
//if lt IE 8
  &lt;html class="no-js ie6 oldie" lang="en"&gt; 
//if IE 7
  &lt;html class="no-js ie7 oldie" lang="en"&gt;
//if IE 8
  &lt;html class="no-js ie8 oldie" lang="en"&gt;
//if gt IE 8
  &lt;!--&gt; &lt;html class="no-js" lang="en"&gt; &lt;!--
head
  meta(charset="utf-8")
  meta(http-equiv="X-UA-Compatible", content="IE=edge,chrome=1")

  title=title
  meta(name="description", content="")
  meta(name="author", content="")
  meta(name="viewport", content="width=device-width,initial-scale=1")
  
  // CSS concatenated and minified via ant build script
  link(rel="stylesheet", href="css/style.css")
  // end CSS

  script(src="js/libs/modernizr-2.0.6.min.js")
body

  #container
    header
    #main(role="main")!=body
    footer
  //! end of #container

  script(src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js")
  script
    window.jQuery || document.write('&lt;script src="js/libs/jquery-1.6.2.min.js"&gt;&lt;\\/script&gt;')

  // scripts concatenated and minified via ant build script
  script(src="js/mylibs/underscore.js")
  script(src="js/mylibs/backbone.js")
  script(defer, src="js/plugins.js")
  script(defer, src="js/script.js")
  // end scripts

  // Change UA-XXXXX-X to be your site's ID
  script
    window._gaq = [['_setAccount','UAXXXXXXXX1'],['_trackPageview'],['_trackPageLoadTime']];
    Modernizr.load({load: ('https:' == location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js'});

  //if lt IE 7
    script(src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js")
    script
      window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
&lt;/html&gt;

</pre>

<p><strong>static.html</strong></p>

<p>Alternatively, a static version of our index which doesn't rely on Jade can be put together as follows. See <a href="https://github.com/addyosmani/backbone-boilerplates/blob/master/option1/public/static.html">here</a> for the complete file or below for a sample.</p>

<pre>
 &lt;div id="container"&gt;
    &lt;div id="main" role="main"&gt;

      &lt;!-- Todo App Interface--&gt;

      &lt;div id="todoapp"&gt;
        &lt;div class="title"&gt;
          &lt;h1&gt;Todos&lt;/h1&gt;
        &lt;/div&gt;

        &lt;div class="content"&gt;
          &lt;div id="create-todo"&gt;
            &lt;input id="new-todo" placeholder="What needs to be done?" type=
            "text" /&gt;&lt;span style="display:none;" class="ui-tooltip-top"&gt;Press Enter to
            save this task&lt;/span&gt;
          &lt;/div&gt;

          &lt;div id="todos"&gt;
            &lt;ul id="todo-list"&gt;&lt;/ul&gt;
          &lt;/div&gt;

          &lt;div id="todo-stats"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;


    &lt;!-- Templates--&gt;

      &lt;script id="item-template" type="text/template"&gt;
      &lt;div class="todo &lt;%= done ? 'done' : '' %&gt;"&gt;
      &lt;div class="display"&gt;&lt;input class="check" type="checkbox" &lt;%= done ? 'checked="checked"' : '' %&gt; /&gt;
      &lt;div class="todo-text"&gt;&lt;/div&gt;&lt;span id="todo-destroy"&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="edit"&gt;&lt;input type="text" value="" class="todo-input"/&gt;&lt;/div&gt;&lt;/div&gt;
      &lt;/script&gt;

      &lt;script id="stats-template" type="text/template"&gt;
      &lt;% if (total) { %&gt;
      &lt;span class="todo-count"&gt;&lt;span class="number"&gt;&lt;%= remaining %&gt; &lt;/span&gt;&lt;span class="word"&gt;&lt;%= remaining == 1 ? 'item' : 'items' %&gt;&lt;/span&gt; left.
      &lt;/span&gt;&lt;% } %&gt;
      &lt;% if (done) { %&gt;
      &lt;span class="todo-clear"&gt;&lt;a href="#"&gt; Clear
      &lt;span class="number-done"&gt;&lt;%= done %&gt;&lt;/span&gt; completed
      &lt;span class="word-done"&gt;&lt;%= done == 1 ? 'item' : 'items' %&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;% } %&gt;
      &lt;/script&gt;

    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!--! end of #container--&gt;
</pre>

<h3>Practical Setup</h3>

<p>We've now gone through the major points of developing a RESTful backend using Node.js, Express and Mongoose. Next, let's make sure you can get your environment setup to run the updated Todo app.</p>

<h4>MongoDB</h4>

<p>Once you've downloaded <a href="http://www.mongodb.org/downloads">MongoDB</a>, you'll need to complete two steps to get it up and running.</p>

<p><strong>Data directories</strong></p>

<p>MongoDB stores data in the bin/data/db folder but won't actually create this directory for you. Navigate to where you've downloaded and extracted MongoDB and run the following from terminal:</p>

<pre>
sudo mkdir -p /data/db/
sudo chown `id -u` /data/db
</pre>

<p><strong>Running and connecting to your server</strong></p>

<p>Once this is done, open up two terminal windows. </p>

<p>In the first, <code>cd</code> to your MongoDB bin directory or type in the complete path to it. You'll need to start mongod`.</p>

<pre>
$ ./bin/mongod
</pre>

<p>Next, in the second terminal, start the `mongo&lt;/code shell which will connect up to localhost by default.</p>

<pre>
$ ./bin/mongo
</pre>

<p>That's it!.</p>

<h4>Express and Mongoose</h4>

<p>Option 1 (HTML) and Option 2 (Jade) of the practical download both come with an install.sh bash script. This allows you to easily install Express, Mongoose, Jade (and optionally MongoDB if you prefer to) through npm (the node package manager). </p>

<ul>
<li>Make sure you have Node.js installed. If not, you can grab it <a href="http://nodejs.org/#download">here</a>
</li>
<li>Next run <code>$ ./install.sh</code> at the terminal to install the rest of our dependencies. To see the exact contents of the install.sh file, see below:</li>
</ul><p><strong>install.sh</strong></p>

<pre>
#!/bin/bash
npm install express
npm install mongodb --mongodb:native
npm install mongoose
npm install jade
</pre>

<ul>
<li>After you've installed all of the dependencies for the stack, we can get to cloning the repo containing our practicals and running them. Start by running the below lines:</li>
</ul><pre>
git clone git://github.com/addyosmani/backbone-boilerplates.git
cd option2
node app.js
</pre>

<p>For option1 (without Jade), simply cd into option1 and run <code>node app.js</code> from there.</p>

<p>Finally, either of the example apps can now be accessed by navigating to:</p>

<ul>
<li>Option 1: <code>http://localhost:3000/static.html</code>
</li>
<li>Option 2: <code>http://localhost:3000/todo</code>
</li>
</ul><p>That's it! Whilst there's a lot more than can be done to expand on the concepts covered so far, the base we're reviewed should be enough to get you up and running with this stack if you wish to use them with Backbone. </p>

<p>In the next addition to this section (coming soon), we'll take a look at a stack consisting of Ruby, Sinatra, Haml and more.</p>

<h2><a name="modularjs">Modular JavaScript</a></h2>

<p>When we say an application is modular, we generally mean it's composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</p>

<p>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn't provide developers with the means to import such modules of code in a clean, organized manner. It's one of the concerns with specifications that haven't required great thought until more recent years where the need for more organized JavaScript applications became apparent.</p>

<p>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it's still possible to incur naming collisions in your architecture. There's also no clean way to handle dependency management without some manual effort or third party tools.</p>

<p>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</p>

<p>In this next part of the book, we're going to look at how to use AMD modules and RequireJS for cleanly wrapping units of code in your application into manageable modules.</p>

<h2>Organizing modules with RequireJS and AMD</h2>

<p>In case you haven't used it before, <a href="http://requirejs.org">RequireJS</a> is a popular script loader written by James Burke - a developer who has been quite instrumental in helping shape the AMD module format, which we'll discuss more shortly. Some of RequireJS's capabilities include helping to load multiple script files, helping define modules with or without dependencies and loading in non-script dependencies such as text files.</p>

<p>So, why use RequireJS with Backbone? Although Backbone is excellent when it comes to providing a sanitary structure to your applications, there are a few key areas where some additional help could be used:</p>

<p>1) Backbone doesn't endorse a particular approach to modular-development. Although this means it's quite open-ended for developers to opt for classical patterns like the module-pattern or Object Literals for structuring their apps (which both work fine), it also means developers aren't sure of what works best when other concerns come into play, such as dependency management.</p>

<p>RequireJS is compatible with the AMD (Asynchronous Module Definition) format, a format which was born from a desire to write something better than the 'write lots of script tags with implicit dependencies and manage them manually' approach to development. In addition to allowing you to clearly declare dependencies, AMD works well in the browser, supports string IDs for dependencies, declaring multiple modules in the same file and gives you easy-to-use tools to avoid polluting the global namespace.</p>

<p>2) Let's discuss dependency management a little more as it can actually be quite challenging to get right if you're doing it by hand. When we write modules in JavaScript, we ideally want to be able to handle the reuse of code units intelligently and sometimes this will mean pulling in other modules at run-time whilst at other times you may want to do this dynamically to avoid a large pay-load when the user first hits your application.</p>

<p>Think about the GMail web-client for a moment. When users initially load up the page on their first visit, Google can simply hide widgets such as the chat module until a user has indicated (by clicking 'expand') that they wish to use it. Through dynamic dependency loading, Google could load up the chat module only then, rather than forcing all users to load it when the page first initializes. This can improve performance and load times and can definitely prove useful when building larger applications.</p>

<p>I've previously written <a href="http://addyosmani.com/writing-modular-js">a detailed article</a> covering both AMD and other module formats and script loaders in case you'd like to explore this topic further. The takeaway is that although it's perfectly fine to develop applications without a script loader or clean module format in place, it can be of significant benefit to consider using these tools in your application development.</p>

<h3>Writing AMD modules with RequireJS</h3>

<p>As discussed above, the overall goal for the AMD format is to provide a solution for modular JavaScript that developers can use today. The two key concepts you need to be aware of when using it with a script-loader are a <code>define()</code> method for facilitating module definition and a <code>require()</code> method for handling dependency loading. <code>define()</code> is used to define named or unnamed modules based on the proposal using the following signature:</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">(</span>
    <span class="nx">module_id</span> <span class="cm">/*optional*/</span><span class="p">,</span> 
    <span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span> <span class="cm">/*optional*/</span><span class="p">,</span> 
    <span class="nx">definition</span> <span class="kd">function</span> <span class="cm">/*function for instantiating the module or object*/</span>
<span class="p">);</span>
</pre></div>

<p>As you can tell by the inline comments, the <code>module_id</code> is an optional argument which is typically only required when non-AMD concatenation tools are being used (there may be some other edge cases where it's useful too). When this argument is left out, we call the module 'anonymous'. When working with anonymous modules, the idea of a module's identity is DRY, making it trivial to avoid duplication of filenames and code.</p>

<p>Back to the define signature, the dependencies argument represents an array of dependencies which are required by the module you are defining and the third argument ('definition function') is a function that's executed to instantiate your module. A barebone module (compatible with RequireJS) could be defined using <code>define()</code> as follows:</p>

<div class="highlight"><pre><span class="c1">// A module ID has been omitted here to make the module anonymous</span>

<span class="nx">define</span><span class="p">([</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">],</span> 
    <span class="c1">// module definition function</span>
    <span class="c1">// dependencies (foo and bar) are mapped to function parameters</span>
    <span class="kd">function</span> <span class="p">(</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// return a value that defines the module export</span>
        <span class="c1">// (i.e the functionality we want to expose for consumption)</span>

        <span class="c1">// create your module here</span>
        <span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">doStuff</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Yay! Stuff'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">myModule</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<h4>Alternate syntax</h4>

<p>There is also a <a href="http://requirejs.org/docs/whyamd.html#sugar">sugared version</a> of <code>define()</code> available that allows you to declare your dependencies as local variables using <code>require()</code>. This will feel familiar to anyone who's used node, and can be easier to add or remove dependencies.
Here is the previous snippet using the alternate syntax:</p>

<div class="highlight"><pre><span class="c1">// A module ID has been omitted here to make the module anonymous</span>

<span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">){</span>
        <span class="c1">// module definition function</span>
    <span class="c1">// dependencies (foo and bar) are defined as local vars</span>
    <span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">),</span>
        <span class="nx">bar</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>

        <span class="c1">// return a value that defines the module export</span>
        <span class="c1">// (i.e the functionality we want to expose for consumption)</span>

        <span class="c1">// create your module here</span>
        <span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">doStuff</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Yay! Stuff'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">myModule</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>The <code>require()</code> method is typically used to load code in a top-level JavaScript file or within a module should you wish to dynamically fetch dependencies. An example of its usage is:</p>

<div class="highlight"><pre><span class="c1">// Consider 'foo' and 'bar' are two external modules</span>
<span class="c1">// In this example, the 'exports' from the two modules loaded are passed as</span>
<span class="c1">// function arguments to the callback (foo and bar)</span>
<span class="c1">// so that they can similarly be accessed</span>

<span class="nx">require</span><span class="p">([</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// rest of your code here</span>
        <span class="nx">foo</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>

<p><strong>Wrapping modules, views and other components with AMD</strong></p>

<p>Now that we've taken a look at how to define AMD modules, let's review how to go about wrapping components like views and collections so that they can also be easily loaded as dependencies for any parts of your application that require them. At it's simplest, a Backbone model may just require Backbone and Underscore.js. These are considered it's dependencies and so, to write an AMD model module, we would simply do this:</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">'underscore'</span><span class="p">,</span> <span class="s1">'backbone'</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Default attributes </span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">content</span><span class="o">:</span> <span class="s2">"hello world"</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="c1">// A dummy initialization method</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"content"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="s2">"content"</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">defaults</span><span class="p">.</span><span class="nx">content</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">},</span>

    <span class="nx">clear</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
    <span class="p">}</span>

  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">myModel</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>Note how we alias Underscore.js's instance to <code>_</code> and Backbone to just <code>Backbone</code>, making it very trivial to convert non-AMD code over to using this module format. For a view which might require other dependencies such as jQuery, this can similarly be done as follows:</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
  <span class="s1">'jquery'</span><span class="p">,</span>
  <span class="s1">'underscore'</span><span class="p">,</span> 
  <span class="s1">'backbone'</span><span class="p">,</span>
  <span class="s1">'collections/mycollection'</span><span class="p">,</span>
  <span class="s1">'views/myview'</span>
  <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">,</span> <span class="nx">myCollection</span><span class="p">,</span> <span class="nx">myView</span><span class="p">){</span>

  <span class="kd">var</span> <span class="nx">AppView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="p">...</span>
</pre></div>

<p>Aliasing to the dollar-sign (<code>$</code>), once again makes it very easy to encapsulate any part of an application you wish using AMD.</p>

<h2>External [Underscore/Handlebars/Mustache] templates using RequireJS</h2>

<p>Moving your [Underscore/Mustache/Handlebars] templates to external files is actually quite straight-forward. As this application makes use of RequireJS, I'll discuss how to implement external templates using this specific script loader.</p>

<p>RequireJS has a special plugin called text.js which is used to load in text file dependencies. To use the text plugin, simply follow these simple steps:</p>

<ol>
<li><p>Download the plugin from <a href="http://requirejs.org/docs/download.html#text">http://requirejs.org/docs/download.html#text</a> and place it in either the same directory as your application's main JS file or a suitable sub-directory.</p></li>
<li><p>Next, include the text.js plugin in your initial RequireJS configuration options. In the code snippet below, we assume that RequireJS is being included in our page prior to this code snippet being executed. Any of the other scripts being loaded are just there for the sake of example.</p></li>
</ol><div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">(</span> <span class="p">{</span>
    <span class="nx">paths</span><span class="o">:</span> <span class="p">{</span>
        <span class="s1">'backbone'</span><span class="o">:</span>         <span class="s1">'libs/AMDbackbone-0.5.3'</span><span class="p">,</span>
        <span class="s1">'underscore'</span><span class="o">:</span>       <span class="s1">'libs/underscore-1.2.2'</span><span class="p">,</span>
        <span class="s1">'text'</span><span class="o">:</span>             <span class="s1">'libs/require/text'</span><span class="p">,</span>
        <span class="s1">'jquery'</span><span class="o">:</span>           <span class="s1">'libs/jQuery-1.7.1'</span><span class="p">,</span>
        <span class="s1">'json2'</span><span class="o">:</span>            <span class="s1">'libs/json2'</span><span class="p">,</span>
        <span class="s1">'datepicker'</span><span class="o">:</span>       <span class="s1">'libs/jQuery.ui.datepicker'</span><span class="p">,</span>
        <span class="s1">'datepickermobile'</span><span class="o">:</span> <span class="s1">'libs/jquery.ui.datepicker.mobile'</span><span class="p">,</span>
        <span class="s1">'jquerymobile'</span><span class="o">:</span>     <span class="s1">'libs/jquery.mobile-1.0'</span>
    <span class="p">},</span>
    <span class="nx">baseUrl</span><span class="o">:</span> <span class="s1">'app'</span>
<span class="p">}</span> <span class="p">);</span>
</pre></div>

<ol>
<li>When the <code>text!</code> prefix is used for a dependency, RequireJS will automatically load the text plugin and treat the dependency as a text resource. A typical example of this in action may look like..</li>
</ol><div class="highlight"><pre><span class="nx">require</span><span class="p">([</span><span class="s1">'js/app'</span><span class="p">,</span> <span class="s1">'text!templates/mainView.html'</span><span class="p">],</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">mainView</span><span class="p">){</span>
        <span class="c1">// the contents of the mainView file will be</span>
        <span class="c1">// loaded into mainView for usage.</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></div>

<ol>
<li>Finally we can use the text resource that's been loaded for templating purposes. You're probably used to storing your HTML templates inline using a script with a specific identifier.</li>
</ol><p>With Underscore.js's micro-templating (and jQuery) this would typically be:</p>

<p>HTML:</p>

<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/template"</span> <span class="na">id=</span><span class="s">"mainViewTemplate"</span><span class="nt">&gt;</span>
    <span class="o">&lt;%</span> <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span> <span class="nx">person</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">person_item</span> <span class="p">){</span> <span class="o">%&gt;</span>
        <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;%=</span> <span class="nx">person_item</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"name"</span><span class="p">)</span> <span class="o">%&gt;&lt;</span><span class="err">/li&gt;  </span>
    <span class="o">&lt;%</span> <span class="p">});</span> <span class="o">%&gt;</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>

<p>JS:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">compiled_template</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span> <span class="nx">$</span><span class="p">(</span><span class="s1">'#mainViewTemplate'</span><span class="p">).</span><span class="nx">html</span><span class="p">()</span> <span class="p">);</span>
</pre></div>

<p>With RequireJS and the text plugin however, it's as simple as saving your template into an external text file (say, <code>mainView.html</code>) and doing the following:</p>

<div class="highlight"><pre><span class="nx">require</span><span class="p">([</span><span class="s1">'js/app'</span><span class="p">,</span> <span class="s1">'text!templates/mainView.html'</span><span class="p">],</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">mainView</span><span class="p">){</span>

        <span class="kd">var</span> <span class="nx">compiled_template</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span> <span class="nx">mainView</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></div>

<p>That's it!. You can then go applying your template to a view in Backbone doing something like:</p>

<div class="highlight"><pre><span class="nx">collection</span><span class="p">.</span><span class="nx">someview</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">html</span><span class="p">(</span> <span class="nx">compiled_template</span><span class="p">(</span> <span class="p">{</span> <span class="nx">results</span><span class="o">:</span> <span class="nx">collection</span><span class="p">.</span><span class="nx">models</span> <span class="p">}</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>

<p>All templating solutions will have their own custom methods for handling template compilation, but if you understand the above, substituting Underscore's micro-templating for any other solution should be fairly trivial.</p>

<p><strong>Note:</strong> You may also be interested in looking at <a href="https://github.com/ZeeAgency/requirejs-tpl">Require.js tpl</a>. It's an AMD-compatible version of the Underscore templating system that also includes support for optimization (pre-compiled templates) which can lead to better performance and no evals. I have yet to use it myself, but it comes as a recommended resource.</p>

<h2>Optimizing Backbone apps for production with the RequireJS Optimizer</h2>

<p>As experienced developers may know, an essential final step when writing both small and large JavaScript web applications is the build process.  The majority of non-trivial apps are likely to consist of more than one or two scripts and so optimizing, minimizing and concatenating your scripts prior to pushing them to production will require your users to download a reduced number (if not just one) script file.</p>

<p>Note: If you haven't looked at build processes before and this is your first time hearing about them, you might find <a href="http://addyosmani.com/blog/client-side-build-process/">my post and screencast on this topic</a> useful.</p>

<p>With some other structural JavaScript frameworks, my recommendation would normally be to implicitly use YUI Compressor or Google's closure compiler tools, but we have a slightly more elegant method available, when it comes to Backbone if you're using RequireJS. RequireJS has a command line optimization tool called r.js which has a number of capabilities, including:</p>

<ul>
<li>Concatenating specific scripts and minifying them using external tools such as UglifyJS (which is used by default) or Google's Closure Compiler for optimal browser delivery, whilst preserving the ability to dynamically load modules</li>
<li>Optimizing CSS and stylesheets by inlining CSS files imported using <a href="https://github.com/import" class="user-mention">@import</a>, stripping out comments etc.</li>
<li>The ability to run AMD projects in both Node and Rhino (more on this later)</li>
</ul><p>You'll notice that I mentioned the word 'specific' in the first bullet point. The RequireJS optimizer only concatenates module scripts that have been specified in arrays of string literals passed to top-level (i.e non-local) require and define calls. As clarified by the <a href="http://requirejs.org/docs/optimization.html">optimizer docs</a> this means that Backbone modules defined like this:</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">'jquery'</span><span class="p">,</span><span class="s1">'backbone'</span><span class="p">,</span><span class="s1">'underscore'</span><span class="p">,</span> <span class="s1">'collections/sample'</span><span class="p">,</span><span class="s1">'views/test'</span><span class="p">],</span> 
    <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span><span class="nx">Backbone</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">Sample</span><span class="p">,</span> <span class="nx">Test</span><span class="p">){</span>
        <span class="c1">//...</span>
    <span class="p">});</span>
</pre></div>

<p>will combine fine, however inline dependencies such as:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">models</span> <span class="o">=</span> <span class="nx">someCondition</span> <span class="o">?</span> <span class="p">[</span><span class="s1">'models/ab'</span><span class="p">,</span><span class="s1">'models/ac'</span><span class="p">]</span> <span class="o">:</span> <span class="p">[</span><span class="s1">'models/ba'</span><span class="p">,</span><span class="s1">'models/bc'</span><span class="p">];</span>
</pre></div>

<p>will be ignored. This is by design as it ensures that dynamic dependency/module loading can still take place even after optimization. </p>

<p>Although the RequireJS optimizer works fine in both Node and Java environments, it's strongly recommended to run it under Node as it executes significantly faster there. In my experience, it's a piece of cake to get setup with either environment, so go for whichever you feel most comfortable with. </p>

<p>To get started with r.js, grab it from the <a href="http://requirejs.org/docs/download.html#rjs">RequireJS download page</a> or <a href="http://requirejs.org/docs/optimization.html#download">through NPM</a>. Now, the RequireJS optimizer works absolutely fine for single script and CSS files, but for most cases you'll want to actually optimize an entire Backbone project. You <em>could</em> do this completely from the command-line, but a cleaner option is using build profiles.</p>

<p>Below is an example of a build file taken from the modular jQuery Mobile app referenced later in this book. A <strong>build profile</strong> (commonly named <code>app.build.js</code>) informs RequireJS to copy all of the content of <code>appDir</code> to a directory defined by <code>dir</code> (in this case <code>../release</code>). This will apply all of the necessary optimizations inside the release folder. The <code>baseUrl</code> is used to resolve the paths for your modules. It should ideally be relative to <code>appDir</code>.</p>

<p>Near the bottom of this sample file, you'll see an array called <code>modules</code>. This is where you specify the module names you wish to have optimized. In this case we're optimizing the main application called 'app', which maps to <code>appDir/app.js</code>. If we had set the <code>baseUrl</code> to 'scripts', it would be mapped to <code>appDir/scripts/app.js</code>.</p>

<div class="highlight"><pre><span class="p">({</span>
    <span class="nx">appDir</span><span class="o">:</span> <span class="s2">"./"</span><span class="p">,</span>
    <span class="nx">baseUrl</span><span class="o">:</span> <span class="s2">"./"</span><span class="p">,</span>
    <span class="nx">dir</span><span class="o">:</span> <span class="s2">"../release"</span><span class="p">,</span>
    <span class="nx">paths</span><span class="o">:</span> <span class="p">{</span>
       <span class="s1">'backbone'</span><span class="o">:</span>          <span class="s1">'libs/AMDbackbone-0.5.3'</span><span class="p">,</span>
        <span class="s1">'underscore'</span><span class="o">:</span>       <span class="s1">'libs/underscore-1.2.2'</span><span class="p">,</span>
        <span class="s1">'jquery'</span><span class="o">:</span>           <span class="s1">'libs/jQuery-1.7.1'</span><span class="p">,</span>
        <span class="s1">'json2'</span><span class="o">:</span>            <span class="s1">'libs/json2'</span><span class="p">,</span>
        <span class="s1">'datepicker'</span><span class="o">:</span>       <span class="s1">'libs/jQuery.ui.datepicker'</span><span class="p">,</span>
        <span class="s1">'datepickermobile'</span><span class="o">:</span> <span class="s1">'libs/jquery.ui.datepicker.mobile'</span><span class="p">,</span>
        <span class="s1">'jquerymobile'</span><span class="o">:</span>     <span class="s1">'libs/jquery.mobile-1.0'</span>
    <span class="p">},</span>
    <span class="nx">optimize</span><span class="o">:</span> <span class="s2">"uglify"</span><span class="p">,</span>
    <span class="nx">modules</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nx">name</span><span class="o">:</span> <span class="s2">"app"</span><span class="p">,</span>
            <span class="nx">exclude</span><span class="o">:</span> <span class="p">[</span>
                <span class="c1">// If you prefer not to include certain libs exclude them here</span>
            <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">})</span>
</pre></div>

<p>The way the build system in r.js works is that it traverses app.js (whatever modules you've passed) and resolved dependencies, concatenating them into the final <code>release</code>(dir) folder. CSS is treated the same way.</p>

<p>The build profile is usually placed inside the 'scripts' or 'js' directory of your project. As per the docs, this file can however exist anywhere you wish, but you'll need to edit the contents of your build profile accordingly. </p>

<p>Finally, to run the build, execute the following command once inside your <code>appDir</code> or <code>appDir/scripts</code> directory:</p>

<div class="highlight"><pre><span class="nx">node</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="nx">r</span><span class="p">.</span><span class="nx">js</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">app</span><span class="p">.</span><span class="nx">build</span><span class="p">.</span><span class="nx">js</span>
</pre></div>

<p>That's it. As long as you have UglifyJS/Closure tools setup correctly, r.js should be able to easily optimize your entire Backbone project in just a few key-strokes. If you would like to learn more about build profiles, James Burke has a <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js">heavily commented sample file</a> with all the possible options available.</p>

<h2><a href="#practical_modularapp">Practical: Building a modular Backbone Todo app with AMD &amp; RequireJS</a></h2>

<p>In this chapter, we'll look at our first practical Backbone &amp; RequireJS project - how to build a modular Todo application. The application will allow us to add new todos, edit new todos and clear todo items that have been marked as completed. For a more advanced practical, see the section on mobile Backbone development.</p>

<p>The complete code for the application can can be found in the <code>practicals/modular-todo-app</code> folder of this repo (thanks to Thomas Davis and Jérôme Gravel-Niquet). Alternatively grab a copy of my side-project <a href="https://github.com/addyosmani/todomvc">TodoMVC</a> which contains the sources to both AMD and non-AMD versions.</p>

<p><strong>Note:</strong> Thomas may be covering a practical on this exercise in more detail on <a href="http://backbonetutorials.com">backbonetutorials.com</a> at some point soon, but for this section I'll be covering what I consider the core concepts.</p>

<h3>Overview</h3>

<p>Writing a 'modular' Backbone application can be a straight-forward process. There are however, some key conceptual differences to be aware of if opting to use AMD as your module format of choice:</p>

<ul>
<li>As AMD isn't a standard native to JavaScript or the browser, it's necessary to use a script loader (such as RequireJS or curl.js) in order to support defining components and modules using this module format. As we've already reviewed, there are a number of advantages to using the AMD as well as RequireJS to assist here.</li>
<li>Models, views, controllers and routers need to be encapsulated <em>using</em> the AMD-format. This allows each component of our Backbone application to cleanly manage dependencies (e.g collections required by a view) in the same way that AMD allows non-Backbone modules to.</li>
<li>Non-Backbone components/modules (such as utilities or application helpers) can also be encapsulated using AMD. I encourage you to try developing these modules in such a way that they can both be used and tested independent of your Backbone code as this will increase their ability to be re-used elsewhere.</li>
</ul><p>Now that we've reviewed the basics, let's take a look at developing our application. For reference, the structure of our app is as follows:</p>

<pre>
index.html
...js/
    main.js
    .../models
            todo.js
    .../views
            app.js
            todos.js
    .../collections
            todos.js
    .../templates
            stats.html
            todos.html
    ../libs
        .../backbone
        .../jquery
        .../underscore
        .../require
                require.js
                text.js
...css/
</pre>

<h3>Markup</h3>

<p>The markup for the application is relatively simple and consists of three primary parts: an input section for entering new todo items (<code>create-todo</code>), a list section to display existing items (which can also be edited in-place) (<code>todo-list</code>) and finally a section summarizing how many items are left to be completed (<code>todo-stats</code>).</p>

<pre>
&lt;div id="todoapp"&gt;

      &lt;div class="content"&gt;

        &lt;div id="create-todo"&gt;
          &lt;input id="new-todo" placeholder="What needs to be done?" type="text" /&gt;
          &lt;span class="ui-tooltip-top"&gt;Press Enter to save this task&lt;/span&gt;
        &lt;/div&gt;

        &lt;div id="todos"&gt;
          &lt;ul id="todo-list"&gt;&lt;/ul&gt;
        &lt;/div&gt;

        &lt;div id="todo-stats"&gt;&lt;/div&gt;

      &lt;/div&gt;

&lt;/div&gt;
</pre>

<p>The rest of the tutorial will now focus on the JavaScript side of the practical.</p>

<h3>Configuration options</h3>

<p>If you've read the earlier chapter on AMD, you may have noticed that explicitly needing to define each dependency a Backbone module (view, collection or other module) may require with it can get a little tedious. This can however be improved.</p>

<p>In order to simplify referencing common paths the modules in our application may use, we use a RequireJS <a href="http://requirejs.org/docs/api.html#config">configuration object</a>, which is typically defined as a top-level script file. Configuration objects have a number of useful capabilities, the most useful being mode name-mapping. Name-maps are basically a key:value pair, where the key defines the alias you wish to use for a path and the value represents the true location of the path.</p>

<p>In the code-sample below, you can see some typical examples of common name-maps which include: <code>backbone</code>, <code>underscore</code>, <code>jquery</code> and depending on your choice, the RequireJS <code>text</code> plugin, which assists with loading text assets like templates.</p>

<p><strong>main.js</strong></p>

<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
  <span class="nx">baseUrl</span><span class="o">:</span><span class="s1">'../'</span><span class="p">,</span>
  <span class="nx">paths</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">jquery</span><span class="o">:</span> <span class="s1">'libs/jquery/jquery-min'</span><span class="p">,</span>
    <span class="nx">underscore</span><span class="o">:</span> <span class="s1">'libs/underscore/underscore-min'</span><span class="p">,</span>
    <span class="nx">backbone</span><span class="o">:</span> <span class="s1">'libs/backbone/backbone-optamd3-min'</span><span class="p">,</span>
    <span class="nx">text</span><span class="o">:</span> <span class="s1">'libs/require/text'</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">require</span><span class="p">([</span><span class="s1">'views/app'</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">AppView</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">app_view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppView</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>The <code>require()</code> at the end of our main.js file is simply there so we can load and instantiation the primary view for our application (<code>views/app.js</code>). You'll commonly see both this and the configuration object included the most top-level script file for a project.</p>

<p>In addition to offering name-mapping, the configuration object can be used to define additional properties such as <code>waitSeconds</code> - the number of seconds to wait before script loading times out and <code>locale</code>, should you wish to load up i18n bundles for custom languages. The <code>baseUrl</code> is simply the path to use for module lookups.</p>

<p>For more information on configuration objects, please feel free to check out the excellent guide to them in the <a href="http://requirejs.org/docs/api.html#config">RequireJS docs</a>.</p>

<h3>Modularizing our models, views and collections</h3>

<p>Before we dive into AMD-wrapped versions of our Backbone components, let's review a sample of a non-AMD view. The following view listens for changes to its model (a Todo item) and re-renders if a user edits the value of the item.   </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">TodoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">//... is a list tag.</span>
    <span class="nx">tagName</span><span class="o">:</span>  <span class="s2">"li"</span><span class="p">,</span>

    <span class="c1">// Cache the template function for a single item.</span>
    <span class="nx">template</span><span class="o">:</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#item-template'</span><span class="p">).</span><span class="nx">html</span><span class="p">()),</span>

    <span class="c1">// The DOM events specific to an item.</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"click .check"</span>              <span class="o">:</span> <span class="s2">"toggleDone"</span><span class="p">,</span>
      <span class="s2">"dblclick div.todo-content"</span> <span class="o">:</span> <span class="s2">"edit"</span><span class="p">,</span>
      <span class="s2">"click span.todo-destroy"</span>   <span class="o">:</span> <span class="s2">"clear"</span><span class="p">,</span>
      <span class="s2">"keypress .todo-input"</span>      <span class="o">:</span> <span class="s2">"updateOnEnter"</span>
    <span class="p">},</span>

    <span class="c1">// The TodoView listens for changes to its model, re-rendering. Since there's</span>
    <span class="c1">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</span>
    <span class="c1">// app, we set a direct reference on the model for convenience.</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>      
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'change'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="p">...</span>
</pre></div>

<p>Note how for templating the common practice of referencing a script by an ID (or other selector) and obtaining its value is used. This of course requires that the template being accessed is implicitly defined in our markup. The following is the 'embedded' version of our template being referenced above:</p>

<pre>
&lt;script type="text/template" id="item-template"&gt;
      &lt;div class="todo &lt;%= done ? 'done' : '' %&gt;"&gt;
        &lt;div class="display"&gt;
          &lt;input class="check" type="checkbox" &lt;%= done ? 'checked="checked"' : '' %&gt; /&gt;
          &lt;div class="todo-content"&gt;&lt;/div&gt;
          &lt;span class="todo-destroy"&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="edit"&gt;
          &lt;input class="todo-input" type="text" value="" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
&lt;/script&gt;
</pre>

<p>Whilst there is nothing wrong with the template itself, once we begin to develop larger applications requiring multiple templates, including them all in our markup on page-load can quickly become both unmanageable and come with performance costs. We'll look at solving this problem in a minute.</p>

<p>Let's now take a look at the AMD-version of our view. As discussed earlier, the 'module' is wrapped using AMD's <code>define()</code> which allows us to specify the dependencies our view requires. Using the mapped paths to 'jquery' etc. simplifies referencing common dependencies and instances of dependencies are themselves mapped to local variables that we can access (e.g 'jquery' is mapped to <code>$</code>).</p>

<p><strong>views/todos.js</strong></p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
  <span class="s1">'jquery'</span><span class="p">,</span> 
  <span class="s1">'underscore'</span><span class="p">,</span> 
  <span class="s1">'backbone'</span><span class="p">,</span>
  <span class="s1">'text!templates/todos.html'</span>
  <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">,</span> <span class="nx">todosTemplate</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">TodoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">//... is a list tag.</span>
    <span class="nx">tagName</span><span class="o">:</span>  <span class="s2">"li"</span><span class="p">,</span>

    <span class="c1">// Cache the template function for a single item.</span>
    <span class="nx">template</span><span class="o">:</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">todosTemplate</span><span class="p">),</span>

    <span class="c1">// The DOM events specific to an item.</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"click .check"</span>              <span class="o">:</span> <span class="s2">"toggleDone"</span><span class="p">,</span>
      <span class="s2">"dblclick div.todo-content"</span> <span class="o">:</span> <span class="s2">"edit"</span><span class="p">,</span>
      <span class="s2">"click span.todo-destroy"</span>   <span class="o">:</span> <span class="s2">"clear"</span><span class="p">,</span>
      <span class="s2">"keypress .todo-input"</span>      <span class="o">:</span> <span class="s2">"updateOnEnter"</span>
    <span class="p">},</span>

    <span class="c1">// The TodoView listens for changes to its model, re-rendering. Since there's</span>
    <span class="c1">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</span>
    <span class="c1">// app, we set a direct reference on the model for convenience.</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>      
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'change'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>

    <span class="c1">// Re-render the contents of the todo item.</span>
    <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()));</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setContent</span><span class="p">();</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>

    <span class="c1">// Use `jQuery.text` to set the contents of the todo item.</span>
    <span class="nx">setContent</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'content'</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todo-content'</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">input</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todo-input'</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'blur'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">close</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="p">...</span>
</pre></div>

<p>From a maintenance perspective, there's nothing logically different in this version of our view, except for how we approach templating. </p>

<p>Using the RequireJS text plugin (the dependency marked <code>text</code>), we can actually store all of the contents for the template we looked at earlier in an external file (todos.html).</p>

<p><strong>templates/todos.html</strong></p>

<pre>
&lt;div class="todo &lt;%= done ? 'done' : '' %&gt;"&gt;
    &lt;div class="display"&gt;
      &lt;input class="check" type="checkbox" &lt;%= done ? 'checked="checked"' : '' %&gt; /&gt;
      &lt;div class="todo-content"&gt;&lt;/div&gt;
      &lt;span class="todo-destroy"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="edit"&gt;
      &lt;input class="todo-input" type="text" value="" /&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>There's no longer a need to be concerned with IDs for the template as we can map it's contents to a local variable (in this case <code>todosTemplate</code>). We then simply pass this to the Underscore.js templating function <code>_.template()</code> the same way we normally would have the value of our template script.</p>

<p>Next, let's look at how to define models as dependencies which can be pulled into collections. Here's an AMD-compatible model module, which has two default values: a <code>content</code> attribute for the content of a Todo item and a boolean <code>done</code> state, allowing us to trigger whether the item has been completed or not.</p>

<p><strong>models/todo.js</strong></p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">'underscore'</span><span class="p">,</span> <span class="s1">'backbone'</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">TodoModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Default attributes for the todo.</span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">content</span><span class="o">:</span> <span class="s2">"empty todo..."</span><span class="p">,</span>
      <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span>
    <span class="p">},</span>

    <span class="c1">// Ensure that each todo created has `content`.</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"content"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="s2">"content"</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">defaults</span><span class="p">.</span><span class="nx">content</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">},</span>

    <span class="c1">// Toggle the `done` state of this todo item.</span>
    <span class="nx">toggle</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">save</span><span class="p">({</span><span class="nx">done</span><span class="o">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"done"</span><span class="p">)});</span>
    <span class="p">},</span>

    <span class="c1">// Remove this Todo from *localStorage* and delete its view.</span>
    <span class="nx">clear</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
    <span class="p">}</span>

  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">TodoModel</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>As per other types of dependencies, we can easily map our model module to a local variable (in this case <code>Todo</code>) so it can be referenced as the model to use for our <code>TodosCollection</code>. This collection also supports a simple <code>done()</code> filter for narrowing down Todo items that have been completed and a <code>remaining()</code> filter for those that are still outstanding.</p>

<p><strong>collections/todos.js</strong></p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
  <span class="s1">'underscore'</span><span class="p">,</span> 
  <span class="s1">'backbone'</span><span class="p">,</span> 
  <span class="s1">'libs/backbone/localstorage'</span><span class="p">,</span> 
  <span class="s1">'models/todo'</span>
  <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">,</span> <span class="nx">Store</span><span class="p">,</span> <span class="nx">Todo</span><span class="p">){</span>

    <span class="kd">var</span> <span class="nx">TodosCollection</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Reference to this collection's model.</span>
    <span class="nx">model</span><span class="o">:</span> <span class="nx">Todo</span><span class="p">,</span>

    <span class="c1">// Save all of the todo items under the `"todos"` namespace.</span>
    <span class="nx">localStorage</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Store</span><span class="p">(</span><span class="s2">"todos"</span><span class="p">),</span>

    <span class="c1">// Filter down the list of all todo items that are finished.</span>
    <span class="nx">done</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">todo</span><span class="p">){</span> <span class="k">return</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'done'</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">},</span>

    <span class="c1">// Filter down the list to only todo items that are still not finished.</span>
    <span class="nx">remaining</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">without</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">done</span><span class="p">());</span>
    <span class="p">},</span>
    <span class="p">...</span>
</pre></div>

<p>In addition to allowing users to add new Todo items from views (which we then insert as models in a collection), we ideally also want to be able to display how many items have been completed and how many are remaining. We've already defined filters that can provide us this information in the above collection, so let's use them in our main application view.</p>

<p><strong>views/app.js</strong></p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
  <span class="s1">'jquery'</span><span class="p">,</span>
  <span class="s1">'underscore'</span><span class="p">,</span> 
  <span class="s1">'backbone'</span><span class="p">,</span>
  <span class="s1">'collections/todos'</span><span class="p">,</span>
  <span class="s1">'views/todos'</span><span class="p">,</span>
  <span class="s1">'text!templates/stats.html'</span>
  <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">Backbone</span><span class="p">,</span> <span class="nx">Todos</span><span class="p">,</span> <span class="nx">TodoView</span><span class="p">,</span> <span class="nx">statsTemplate</span><span class="p">){</span>

  <span class="kd">var</span> <span class="nx">AppView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="c1">// Instead of generating a new element, bind to the existing skeleton of</span>
    <span class="c1">// the App already present in the HTML.</span>
    <span class="nx">el</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="s2">"#todoapp"</span><span class="p">),</span>

    <span class="c1">// Our template for the line of statistics at the bottom of the app.</span>
    <span class="nx">statsTemplate</span><span class="o">:</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">statsTemplate</span><span class="p">),</span>

    <span class="c1">// ...events, initialize() etc. can be seen in the complete file</span>

    <span class="c1">// Re-rendering the App just means refreshing the statistics -- the rest</span>
    <span class="c1">// of the app doesn't change.</span>
    <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">done</span> <span class="o">=</span> <span class="nx">Todos</span><span class="p">.</span><span class="nx">done</span><span class="p">().</span><span class="nx">length</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#todo-stats'</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statsTemplate</span><span class="p">({</span>
        <span class="nx">total</span><span class="o">:</span>      <span class="nx">Todos</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">done</span><span class="o">:</span>       <span class="nx">Todos</span><span class="p">.</span><span class="nx">done</span><span class="p">().</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">remaining</span><span class="o">:</span>  <span class="nx">Todos</span><span class="p">.</span><span class="nx">remaining</span><span class="p">().</span><span class="nx">length</span>
      <span class="p">}));</span>
    <span class="p">},</span>
    <span class="p">...</span>
</pre></div>

<p>Above, we map the second template for this project, <code>templates/stats.html</code> to <code>statsTemplate</code> which is used for rendering the overall <code>done</code> and <code>remaining</code> states. This works by simply passing our template the length of our overall Todos collection (<code>Todos.length</code> - the number of Todo items created so far) and similarly the length (counts) for items that have been completed (<code>Todos.done().length</code>) or are remaining (<code>Todos.remaining().length</code>).</p>

<p>The contents of our <code>statsTemplate</code> can be seen below. It's nothing too complicated, but does use ternary conditions to evaluate whether we should state there's "1 item" or "2 item<i>s</i>" in a particular state.</p>

<pre>
 &lt;% if (total) { %&gt;
        &lt;span class="todo-count"&gt;
          &lt;span class="number"&gt;&lt;%= remaining %&gt;&lt;/span&gt;
          &lt;span class="word"&gt;&lt;%= remaining == 1 ? 'item' : 'items' %&gt;&lt;/span&gt; left.
        &lt;/span&gt;
      &lt;% } %&gt;
      &lt;% if (done) { %&gt;
        &lt;span class="todo-clear"&gt;
          &lt;a href="#"&gt;
            Clear &lt;span class="number-done"&gt;&lt;%= done %&gt;&lt;/span&gt;
            completed &lt;span class="word-done"&gt;&lt;%= done == 1 ? 'item' : 'items' %&gt;&lt;/span&gt;
          &lt;/a&gt;
        &lt;/span&gt;
      &lt;% } %&gt;
</pre>

<p>The rest of the source for the Todo app mainly consists of code for handling user and application events, but that rounds up most of the core concepts for this practical. </p>

<p>To see how everything ties together, feel free to grab the source by cloning this repo or browse it <a href="https://github.com/addyosmani/backbone-fundamentals/tree/master/practicals/modular-todo-app">online</a> to learn more. I hope you find it helpful!.</p>

<p><strong>Note:</strong> While this first practical doesn't use a build profile as outlined in the chapter on using the RequireJS optimizer, we will be using one in the section on building mobile Backbone applications.</p>

<h2>Decoupling Backbone with the Mediator and Facade patterns</h2>

<p>In this section we'll discuss applying some of the concepts I cover in my article on <a href="http://addyosmani.com/largescalejavascript">Large-scale JavaScript Application development</a> to Backbone. </p>

<h3>Summary</h3>

<p>At a high-level, one architecture that works for such applications is something which is:</p>

<ul>
<li>
<strong>Highly decoupled</strong>: encouraging modules to only publish and subscribe to events of interest rather than directly communicating with each other. This helps us to build applications who's units of code aren't highly tied (coupled) together and can thus be reused more easily.</li>
<li>
<strong>Supports module-level security</strong>: whereby modules are only able to execute behavior they've been permitted to. Application security is an area which is often overlooked in JavaScript applications, but can be quite easily implemented in a flexible manner.</li>
<li>
<strong>Supports failover</strong>: allowing an application continuing to function even if particular modules fail. The typical example I give of this is the GMail chat widget. Imagine being able to build applications in a way that if one widget on the page fails (e.g chat), the rest of your application (mail) can continue to function without being affected.</li>
</ul><p>This is an architecture which has been implemented by a number of different companies in the past, including Yahoo! (for their modularized homepage - which Nicholas Zakas has <a href="http://www.youtube.com/watch?v=vXjVFPosQHw">spoken</a> about) and AOL for some of our upcoming projects. </p>

<p>The three design patterns that make this architecture possible are the:</p>

<ul>
<li>
<strong>Module pattern</strong>: used for encapsulating unique blocks of code, where functions and variables can be kept either public or private. ('private' in the simulation of privacy sense, as of course don't have true privacy in JavaScript)</li>
<li>
<strong>Mediator pattern</strong>: used when the communication between modules may be complex, but is still well defined. If it appears a system may have too many relationships between modules in your code, it may be time to have a central point of control, which is where the pattern fits in.</li>
<li>
<strong>Facade pattern</strong>: used for providing a convenient higher-level interface to a larger body of code, hiding its true underlying complexity</li>
</ul><p>Their specific roles in this architecture can be found below.</p>

<ul>
<li>
<strong>Modules</strong>: There are almost two concepts of what defines a module. As AMD is being used as a module wrapper, technically each model, view and collection can be considered a module. We then have the concept of modules being distinct blocks of code outside of just MVC/MV*. For the latter, these types of 'modules' are primarily concerned with broadcasting and subscribing to events of interest rather than directly communicating with each other.They are made possible through the Mediator pattern.</li>
<li>
<strong>Mediator</strong>: The mediator has a varying role depending on just how you wish to implement it. In my article, I mention using it as a module manager with the ability to start and stop modules at will, however when it comes to Backbone, I feel that simplifying it down to the role of a central 'controller' that provides pub/sub capabilities should suffice. One can of course go all out in terms of building a module system that supports module starting, stopping, pausing etc, however the scope of this is outside of this chapter.</li>
<li>
<strong>Facade</strong>: This acts as a secure middle-layer that both abstracts an application core (Mediator) and relays messages from the modules back to the Mediator so they don't touch it directly. The Facade also performs the duty of application security guard; it checks event notifications from modules against a configuration (permissions.js, which we will look at later) to ensure requests from modules are only processed if they are permitted to execute the behavior passed.</li>
</ul><p>For ease of reference, I sometimes refer to these three patterns grouped together as Aura (a word that means subtle, luminous light).</p>

<h3>Practical</h3>

<p>For the practical section of this chapter, we'll be extending the well-known Backbone Todo application using the three patterns mentioned above. The complete code for this section can be found here: <a href="https://github.com/addyosmani/backbone-aura">https://github.com/addyosmani/backbone-aura</a> and should ideally be run on at minimum, a local HTTP server.</p>

<p>The application is broken down into AMD modules that cover everything from Backbone models through to application-level modules. The views publish events of interest to the rest of the application and modules can then subscribe to these event notifications. </p>

<p>All subscriptions from modules go through a facade (or sandbox). What this does is check against the subscriber name and the 'channel/notification' it's attempting to subscribe to. If a channel <em>doesn't</em> have permissions to be subscribed to (something established through permissions.js), the subscription isn't permitted. </p>

<p><strong>Mediator</strong></p>

<p>Found in <code>aura/mediator.js</code></p>

<p>Below is a very simple AMD-wrapped implementation of the mediator pattern, based on prior work by Ryan Florence. It accepts as it's input an object, to which it attaches <code>publish()</code> and <code>subscribe()</code> methods. In a larger application, the mediator can contain additional utilities, such as handlers for initializing, starting and stopping modules, but for demonstration purposes, these two methods should work fine for our needs.</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>

  <span class="kd">var</span> <span class="nx">channels</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">)</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="nx">obj</span><span class="p">.</span><span class="nx">subscribe</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">subscription</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">subscription</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">obj</span><span class="p">.</span><span class="nx">publish</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">channels</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="nx">i</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>

<span class="p">});</span>
</pre></div>

<p><strong>Facade</strong></p>

<p>Found in <code>aura/facade.js</code></p>

<p>Next, we have an implementation of the facade pattern. Now the classical facade pattern applied to JavaScript would probably look a little like this: </p>

<div class="highlight"><pre>
<span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_private</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">i</span><span class="o">:</span><span class="mi">5</span><span class="p">,</span>
        <span class="nx">get</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'current value:'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">i</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">set</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">val</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="nx">run</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'running'</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">jump</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'jumping'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">facade</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">args</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">_private</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
            <span class="nx">_private</span><span class="p">.</span><span class="nx">get</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nx">args</span><span class="p">.</span><span class="nx">run</span> <span class="p">)</span> <span class="p">{</span>
                <span class="nx">_private</span><span class="p">.</span><span class="nx">run</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}());</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">facade</span><span class="p">({</span><span class="nx">run</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">val</span><span class="o">:</span><span class="mi">10</span><span class="p">});</span>
<span class="c1">//outputs current value: 10, running</span>
</pre></div>

<p>It's effectively a variation of the module pattern, where instead of simply returning an interface of supported methods, your API can completely hide the true implementation powering it, returning something simpler. This allows the logic being performed in the background to be as complex as necessary, whilst all the end-user experiences is a simplified API they pass options to (note how in our case, a single method abstraction is exposed). This is a beautiful way of providing APIs that can be easily consumed.</p>

<p>That said, to keep things simple, our implementation of an AMD-compatible facade will act a little more like a proxy. Modules will communicate directly through the facade to access the mediator's <code>publish()</code> and <code>subscribe()</code> methods, however, they won't as such touch the mediator directly.This enables the facade to provide application-level validation of any subscriptions and publications made.</p>

<p>It also allows us to implement a simple, but flexible, permissions checker (as seen below) which will validate subscriptions made against a permissions configuration to see whether it's permitted or not. </p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span> <span class="s2">"../aura/mediator"</span> <span class="p">,</span> <span class="s2">"../aura/permissions"</span> <span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">mediator</span><span class="p">,</span> <span class="nx">permissions</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">facade</span> <span class="o">=</span> <span class="nx">facade</span> <span class="o">||</span> <span class="p">{};</span>

    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">subscriber</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>

        <span class="c1">// Note: Handling permissions/security is optional here</span>
        <span class="c1">// The permissions check can be removed </span>
        <span class="c1">// to just use the mediator directly.</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">permissions</span><span class="p">.</span><span class="nx">validate</span><span class="p">(</span><span class="nx">subscriber</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)){</span>
            <span class="nx">mediator</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">callback</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">facade</span><span class="p">.</span><span class="nx">publish</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">channel</span><span class="p">){</span>
        <span class="nx">mediator</span><span class="p">.</span><span class="nx">publish</span><span class="p">(</span> <span class="nx">channel</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">facade</span><span class="p">;</span>

<span class="p">});</span>
</pre></div>

<p><strong>Permissions</strong></p>

<p>Found in <code>aura/permissions.js</code></p>

<p>In our simple permissions configuration, we support checking against subscription requests to establish whether they are allowed to clear. This enforces a flexible security layer for the application.</p>

<p>To visually see how this works, consider changing say, permissions -&gt; renderDone -&gt; todoCounter to be false. This will completely disable the application from from rendering or displaying the counts component for Todo items left (because they aren't allowed to subscribe to that event notification). The rest of the Todo app can still however be used without issue. </p>

<p>It's a very dumbed down example of the potential for application security, but imagine how powerful this might be in a large app with a significant number of visual widgets.</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Permissions</span>

    <span class="c1">// A permissions structure can support checking</span>
    <span class="c1">// against subscriptions prior to allowing them </span>
    <span class="c1">// to clear. This enforces a flexible security </span>
    <span class="c1">// layer for your application.</span>

    <span class="kd">var</span> <span class="nx">permissions</span> <span class="o">=</span> <span class="p">{</span>

        <span class="nx">newContentAvailable</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">contentUpdater</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">endContentEditing</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">todoSaver</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">beginContentEditing</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">editFocus</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">addingNewTodo</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">todoTooltip</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">clearContent</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">garbageCollector</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">renderDone</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">todoCounter</span><span class="o">:</span><span class="kc">true</span> <span class="c1">//switch to false to see what happens :)</span>
        <span class="p">},</span>

        <span class="nx">destroyContent</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">todoRemover</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">},</span>

        <span class="nx">createWhenEntered</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">keyboardManager</span><span class="o">:</span><span class="kc">true</span>
        <span class="p">}</span>

    <span class="p">};</span>

    <span class="nx">permissions</span><span class="p">.</span><span class="nx">validate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">subscriber</span><span class="p">,</span> <span class="nx">channel</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">test</span> <span class="o">=</span> <span class="nx">permissions</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="nx">subscriber</span><span class="p">];</span>
        <span class="k">return</span> <span class="nx">test</span><span class="o">===</span><span class="kc">undefined</span><span class="o">?</span> <span class="kc">false</span><span class="o">:</span> <span class="nx">test</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="nx">permissions</span><span class="p">;</span>

<span class="p">});</span>
</pre></div>

<p><strong>Subscribers</strong></p>

<p>Found in <code>subscribers.js</code></p>

<p>Subscriber 'modules' communicate through the facade back to the mediator and perform actions when a notification event of a particular name is published. </p>

<p>For example, when a user enters in a new piece of text for a Todo item and hits 'enter' the application publishes a notification saying two things: a) a new Todo item is available and b) the text content of the new item is X. It's then left up to the rest of the application to do with this information whatever it wishes. </p>

<p>In order to update your Backbone application to primarily use pub/sub, a lot of the work you may end up doing will be moving logic coupled inside of specific views to modules outside of it which are reactionary. </p>

<p>Take the <code>todoSaver</code> for example - it's responsibility is saving new Todo items to models once the a <code>notificationName</code> called 'newContentAvailable' has fired. If you take a look at the permissions structure in the last code sample, you'll notice that 'newContentAvailable' is present there. If I wanted to prevent subscribers from being able to subscribe to this notification, I simply set it to a boolean value of <code>false</code>.</p>

<p>Again, this is a massive oversimplification of how advanced your permissions structures could get, but it's certainly one way of controlling what parts of your application can or can't be accessed by specific modules at any time.</p>

<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">"jquery"</span><span class="p">,</span> <span class="s2">"underscore"</span><span class="p">,</span> <span class="s2">"aura/facade"</span><span class="p">],</span> 
<span class="kd">function</span> <span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">facade</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Subscription 'modules' for our views. These take the </span>
    <span class="c1">// the form facade.subscribe( subscriberName, notificationName , callBack )</span>

    <span class="c1">// Update view with latest todo content</span>
    <span class="c1">// Subscribes to: newContentAvailable</span>

    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'contentUpdater'</span><span class="p">,</span> <span class="s1">'newContentAvailable'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'content'</span><span class="p">);</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todo-content'</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">input</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todo-input'</span><span class="p">);</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'blur'</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">close</span><span class="p">);</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
    <span class="p">});</span>


    <span class="c1">// Save models when a user has finishes editing</span>
    <span class="c1">// Subscribes to: endContentEditing</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'todoSaver'</span><span class="p">,</span><span class="s1">'endContentEditing'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="nx">context</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">save</span><span class="p">({</span>
                <span class="nx">content</span><span class="o">:</span> <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">val</span><span class="p">()</span>
            <span class="p">});</span>
            <span class="nx">$</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">removeClass</span><span class="p">(</span><span class="s2">"editing"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//console.log(e);</span>
        <span class="p">}</span>
    <span class="p">});</span>


    <span class="c1">// Delete a todo when the user no longer needs it</span>
    <span class="c1">// Subscribes to: destroyContent</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'todoRemover'</span><span class="p">,</span><span class="s1">'destroyContent'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="nx">context</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//console.log(e);</span>
        <span class="p">}</span>
    <span class="p">});</span>


    <span class="c1">// When a user is adding a new entry, display a tooltip</span>
    <span class="c1">// Subscribes to: addingNewTodo</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'todoTooltip'</span><span class="p">,</span><span class="s1">'addingNewTodo'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">tooltip</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s2">".ui-tooltip-top"</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">val</span><span class="p">();</span>
        <span class="nx">tooltip</span><span class="p">.</span><span class="nx">fadeOut</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">tooltipTimeout</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">tooltipTimeout</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">==</span> <span class="s1">''</span> <span class="o">||</span> <span class="nx">val</span> <span class="o">==</span> <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">'placeholder'</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                <span class="nx">tooltip</span><span class="p">.</span><span class="nx">show</span><span class="p">().</span><span class="nx">fadeIn</span><span class="p">();</span>
            <span class="p">};</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">tooltipTimeout</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">delay</span><span class="p">(</span><span class="nx">show</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="p">});</span>


    <span class="c1">// Update editing UI on switching mode to editing content</span>
    <span class="c1">// Subscribes to: beginContentEditing</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'editFocus'</span><span class="p">,</span><span class="s1">'beginContentEditing'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">$</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">addClass</span><span class="p">(</span><span class="s2">"editing"</span><span class="p">);</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
    <span class="p">});</span>


    <span class="c1">// Create a new todo entry </span>
    <span class="c1">// Subscribes to: createWhenEntered</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'keyboardManager'</span><span class="p">,</span><span class="s1">'createWhenEntered'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">todos</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">todos</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">newAttributes</span><span class="p">());</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="s1">''</span><span class="p">);</span>
    <span class="p">});</span>



    <span class="c1">// A Todo and remaining entry counter</span>
    <span class="c1">// Subscribes to: renderDone</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'todoCounter'</span><span class="p">,</span><span class="s1">'renderDone'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">Todos</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">done</span> <span class="o">=</span> <span class="nx">Todos</span><span class="p">.</span><span class="nx">done</span><span class="p">().</span><span class="nx">length</span><span class="p">;</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#todo-stats'</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">statsTemplate</span><span class="p">({</span>
            <span class="nx">total</span><span class="o">:</span> <span class="nx">Todos</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
            <span class="nx">done</span><span class="o">:</span> <span class="nx">Todos</span><span class="p">.</span><span class="nx">done</span><span class="p">().</span><span class="nx">length</span><span class="p">,</span>
            <span class="nx">remaining</span><span class="o">:</span> <span class="nx">Todos</span><span class="p">.</span><span class="nx">remaining</span><span class="p">().</span><span class="nx">length</span>
        <span class="p">}));</span>
    <span class="p">});</span>


    <span class="c1">// Clear all completed todos when clearContent is dispatched</span>
    <span class="c1">// Subscribes to: clearContent</span>
    <span class="nx">facade</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'garbageCollector'</span><span class="p">,</span><span class="s1">'clearContent'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">Todos</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">Todos</span><span class="p">.</span><span class="nx">done</span><span class="p">(),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">todo</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">});</span>


<span class="p">});</span>
</pre></div>

<p>That's it for this section. If you've been intrigued by some of the concepts covered, I encourage you to consider taking a look at my <a href="http://addyosmani.com/blog/large-scale-javascript-application-architecture/">slides</a> on Large-scale JS from the jQuery Summit or my longer post on the topic <a href="http://addyosmani.com/largescalejavascript">here</a> for more information. </p>

<h2>Backbone &amp; jQuery Mobile</h2>

<h3>Resolving the routing conflicts</h3>

<p>The first major hurdle developers typically run into when building Backbone applications with jQuery Mobile is that both frameworks have their own opinions about how to handle application navigation. </p>

<p>Backbone's routers offer an explicit way to define custom navigation routes through <code>Backbone.Router</code>, whilst jQuery Mobile encourages the use of URL hash fragments to reference separate 'pages' or views in the same document. jQuery Mobile also supports automatically pulling in external content for links through XHR calls meaning that there can be quite a lot of inter-framework confusion about what a link pointing at '#photo/id' should actually be doing.</p>

<p>Some of the solutions that have been previously proposed to work-around this problem included manually patching Backbone or jQuery Mobile. I discourage opting for these techniques as it becomes necessary to manually patch your framework builds when new releases get made upstream. </p>

<p>There's also <a href="https://github.com/azicchetti/jquerymobile-router">jQueryMobile router</a>, which tries to solve this problem differently, however I think my proposed solution is both simpler and allows both frameworks to cohabit quite peacefully without the need to extend either. What we're after is a way to prevent one framework from listening to hash changes so that we can fully rely on the other (e.g. <code>Backbone.Router</code>) to handle this for us exclusively.</p>

<p>Using jQuery Mobile this can be done by setting: </p>

<div class="highlight"><pre><span class="nx">$</span><span class="p">.</span><span class="nx">mobile</span><span class="p">.</span><span class="nx">hashListeningEnabled</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</pre></div>

<p>prior to initializing any of your other code. </p>

<p>I discovered this method looking through some jQuery Mobile commits that didn't make their way into the official docs, but am happy to see that they are now covered here <a href="http://jquerymobile.com/test/docs/api/globalconfig.html">http://jquerymobile.com/test/docs/api/globalconfig.html</a> in more detail.</p>

<p>The next question that arises is, if we're preventing jQuery Mobile from listening to URL hash changes, how can we still get the benefit of being able to navigate to other sections in a document using the built-in transitions and effects supported? Good question. This can now be solve by simply calling <code>$.mobile.changePage()</code> as follows:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">'#about'</span><span class="p">,</span>
    <span class="nx">effect</span> <span class="o">=</span> <span class="s1">'slideup'</span><span class="p">,</span>
    <span class="nx">reverse</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">changeHash</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="nx">$</span><span class="p">.</span><span class="nx">mobile</span><span class="p">.</span><span class="nx">changePage</span><span class="p">(</span> <span class="nx">url</span> <span class="p">,</span> <span class="p">{</span> <span class="nx">transition</span><span class="o">:</span> <span class="nx">effect</span><span class="p">},</span> <span class="nx">reverse</span><span class="p">,</span> <span class="nx">changeHash</span> <span class="p">);</span>
</pre></div>

<p>In the above sample, <code>url</code> can refer to a URL or a hash identifier to navigate to, <code>effect</code> is simply the transition effect to animate the page in with and the final two parameters decide the direction for the transition (<code>reverse</code>) and whether or not the hash in the address bar should be updated (<code>changeHash</code>). With respect to the latter, I typically set this to false to avoid managing two sources for hash updates, but feel free to set this to true if you're comfortable doing so.</p>

<p><strong>Note:</strong> For some parallel work being done to explore how well the jQuery Mobile Router plugin works with Backbone, you may be interested in checking out <a href="https://github.com/Filirom1/jquery-mobile-backbone-requirejs">https://github.com/Filirom1/jquery-mobile-backbone-requirejs</a>.</p>

<h3>Practical: A Backbone, RequireJS/AMD app with jQuery Mobile</h3>

<p><strong>Note:</strong> The code for this practical can be found in <code>practicals/modular-mobile-app</code>.</p>

<h3>Getting started</h3>

<p>Once you feel comfortable with the <a href="http://msdn.microsoft.com/en-us/scriptjunkie/hh377172.aspx">Backbone fundamentals</a> and you've put together a rough wireframe of the app you may wish to build, start to think about your application architecture. Ideally, you'll want to logically separate concerns so that it's as easy as possible to maintain the app in the future.</p>

<p><strong>Namespacing</strong></p>

<p>For this application, I opted for the nested namespacing pattern. Implemented correctly, this enables you to clearly identify if items being referenced in your app are views, other modules and so on. This initial structure is a sane place to also include application defaults (unless you prefer maintaining those in a separate file).</p>

<div class="highlight"><pre><span class="nb">window</span><span class="p">.</span><span class="nx">mobileSearch</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">mobileSearch</span> <span class="o">||</span> <span class="p">{</span>
    <span class="nx">views</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">appview</span><span class="o">:</span> <span class="k">new</span> <span class="nx">AppView</span>
    <span class="p">},</span>
    <span class="nx">routers</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">workspace</span><span class="o">:</span><span class="k">new</span> <span class="nx">Workspace</span><span class="p">()</span>
    <span class="p">},</span>
    <span class="nx">utils</span><span class="o">:</span> <span class="nx">utils</span><span class="p">,</span>
    <span class="nx">defaults</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">resultsPerPage</span><span class="o">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="nx">safeSearch</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nx">maxDate</span><span class="o">:</span><span class="s1">''</span><span class="p">,</span>
        <span class="nx">minDate</span><span class="o">:</span><span class="s1">'01/01/1970'</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p><strong>Models</strong></p>

<p>In the Flickly application, there are at least two unique types of data that need to be modeled - search results and individual photos, both of which contain additional meta-data like photo titles. If you simplify this down, search results are actually groups of photos in their own right, so the application only requires:</p>

<ul>
<li>A single model (a photo or 'result' entry)</li>
<li>A result collection (containing a group of result entries) for search results</li>
<li>A photo collection (containing one or more result entries) for individual photos or photos with more than one image</li>
</ul><p><strong>Views</strong></p>

<p>The views we'll need include an application view, a search results view and a photo view. Static views or pages of the single-page application which do not require a dynamic element to them (e.g an 'about' page) can be easily coded up in your document's markup, independent of Backbone.</p>

<p><strong>Routers</strong></p>

<p>A number of possible routes need to be taken into consideration:</p>

<ul>
<li>Basic search queries <code>#search/kiwis</code>
</li>
<li>Search queries with additional parameters (e.g sort, pagination) <code>#search/kiwis/srelevance/p7</code>
</li>
<li>Queries for specific photos <code>#photo/93839</code>
</li>
<li>A default route (no parameters passed)</li>
</ul><p>This tutorial will be expanded shortly to fully cover the demo application. In the mean time, please see the practicals folder for the completed application that demonstrates the router resolution discussed earlier between Backbone and jQuery Mobile.</p>

<h3>jQuery Mobile: Going beyond mobile application development</h3>

<p>The majority of jQM apps I've seen in production have been developed for the purpose of providing an optimal experience to users on mobile devices. Given that the framework was developed for this purpose, there's nothing fundamentally wrong with this, but many developers forget that jQM is a UI framework not dissimilar to jQuery UI. It's using the widget factory and is capable of being used for a lot more than we give it credit for.</p>

<p>If you open up Flickly in a desktop browser, you'll get an image search UI that's modeled on Google.com, however, review the components (buttons, text inputs, tabs) on the page for a moment. The desktop UI doesn't look anything like a mobile application yet I'm still using jQM for theming mobile components; the tabs, date-picker, sliders - everything in the desktop UI is re-using what jQM would be providing users on mobile devices. Thanks to some media queries, the desktop UI can make optimal use of whitespace, expanding component blocks out and providing alternative layouts whilst still making use of jQM as a component framework.</p>

<p>The benefit of this is that I don't need to go pulling in jQuery UI separately to be able to take advantage of these features. Thanks to the recent ThemeRoller my components can look pretty much exactly how I would like them to and users of the app can get a jQM UI for lower-resolutions and a jQM-ish UI for everything else.</p>

<p>The takeaway here is just to remember that if you're not (already) going through the hassle of conditional script/style loading based on screen-resolution (using matchMedia.js etc), there are simpler approaches that can be taken to cross-device component theming.</p>

<h2><a name="testing">Testing</a></h2>

<h1>Unit Testing Backbone Applications With Jasmine</h1>

<h2>Introduction</h2>

<p>One definition of unit testing is the process of taking the smallest piece of testable code in an application, isolating it from the remainder of your codebase and determining if it behaves exactly as expected. In this section, we'll be taking a look at how to unit test Backbone applications using a popular JavaScript testing framework called <a href="http://pivotal.github.com/jasmine/">Jasmine</a> from Pivotal Labs.</p>

<p>For an application to be considered 'well'-tested, distinct functionality should ideally have its own separate unit tests where it's tested against the different conditions you expect it to work under. All tests must pass before functionality is considered 'complete'. This allows developers to both modify a unit of code and it's dependencies with a level of confidence about whether these changes have caused any breakage.</p>

<p>As a basic example of unit testing is where a developer may wish to assert whether passing specific values through to a sum function results in the correct output being returned. For an example more relevant to this book, we may wish to assert whether a user adding a new Todo item to a list correctly adds a Model of a specific type to a Todos Collection.</p>

<p>When building modern web-applications, it's typically considered best-practice to include automated unit testing as a part of your development process. Whilst we'll be focusing on Jasmine as a solution for this, there are a number of other alternatives worth considering, including QUnit.</p>

<h2>Jasmine</h2>

<p>Jasmine describes itself as a behavior-driven development (BDD) framework for testing JavaScript code. Before we jump into how the framework works, it's useful to understand exactly what <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> is.</p>

<p>BDD is a second-generation testing approach first described by <a href="http://dannorth.net/introducing-bdd/">Dan North</a> (the authority on BDD) which attempts to test the behavior of software. It's considered second-generation as it came out of merging ideas from Domain driven design (DDD) and lean software development, helping teams to deliver high quality software by answering many of the more confusing questions early on in the agile process. Such questions commonly include those concerning documentation and testing.</p>

<p>If you were to read a book on BDD, it's likely to also be described as being 'outside-in and pull-based'. The reason for this is that it borrows the idea of of pulling features from Lean manufacturing which effectively ensures that the right software solutions are being written by a) focusing on expected outputs of the system and b) ensuring these outputs are achieved.</p>

<p>BDD recognizes that there are usually multiple stakeholders in a project and not a single amorphous user of the system. These different groups will be affected by the software being written in differing ways and will have a varying opinion of what quality in the system means to them. It's for this reason that it's important to understand who the software will be bringing value you and exactly what in it will be valuable to them.</p>

<p>Finally, BDD relies on automation. Once you've defined the quality expected, your team will likely want to check on the functionality of the solution being built regularly and compare it to the results they expect. In order to facilitate this efficiently, the process has to be automated. BDD relies heavily on the automation of specification-testing and Jasmine is a tool which can assist with this. </p>

<p>BDD helps both developers and non-technical stakeholders:</p>

<ul>
<li>Better understand and represent the models of the problems being solved</li>
<li>Explain supported tests cases in a language that non-developers can read</li>
<li>Focus on minimizing translation of the technical code being written and the domain language spoken by the business</li>
</ul><p>What this means is that developers should be able to show Jasmine unit tests to a project stakeholder and (at a high level, thanks to a common vocabulary being used) they'll ideally be able to understand what the code supports. </p>

<p>Developers often implement BDD in unison with another testing paradigm known as <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> (test-driven development). The main idea behind TDD is:</p>

<ul>
<li>Write unit tests which describe the functionality you would like your code to support</li>
<li>Watch these tests fail (as the code to support them hasn't yet been written)</li>
<li>Write code to make the tests pass</li>
<li>Rinse, repeat and refactor</li>
</ul><p>In this chapter we're going to use both BDD (with TDD) to write unit tests for a Backbone application.</p>

<p><strong><em>Note:</em></strong> I've seen a lot of developers also opt for writing tests to validate behavior of their code after having written it. While this is fine, note that it can come with pitfalls such as only testing for behavior your code currently supports, rather than behavior the problem needs to be supported.</p>

<h2>Suites, Specs &amp; Spies</h2>

<p>When using Jasmine, you'll be writing suites and specifications (specs). Suites basically describe scenarios whilst specs describe what can be done in these scenarios.</p>

<p>Each spec is a JavaScript function, described with a call to `<code>it()</code> using a description string and a function. The description should describe the behaviour the particular unit of code should exhibit and keeping in mind BDD, it should ideally be meaningful. Here's an example of a basic spec:</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'should be incrementing in value'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>  
<span class="p">});</span>
</pre></div>

<p>On it's own, a spec isn't particularly useful until expectations are set about the behavior of the code. Expectations in specs are defined using the <code>expect()</code> function and an <a href="https://github.com/pivotal/jasmine/wiki/Matchers">expectation matcher</a> (e.g toEqual(), toBeTruthy(), toContain()). A revised example using an expectation matcher would look like:</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'should be incrementing in value'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>  
    <span class="nx">expect</span><span class="p">(</span><span class="nx">counter</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>The above code passes our behavioral expectation as `<code>counter</code> equals 1. Notice how easy this was to read the expectation on the last line (you probably grokked it without any explanation).</p>

<p>Specs are grouped into suites which we describe using Jasmine's <code>describe()</code> function, again passing a string as a description and a function. The name/description for your suite is typically that of the component or module you're testing. </p>

<p>Jasmine will use it as the group name when it reports the results of the specs you've asked it to run. A simple suite containing our sample spec could look like:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s1">'Stats'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">'can increment a number'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="p">...</span>
    <span class="p">});</span>

    <span class="nx">it</span><span class="p">(</span><span class="s1">'can subtract a number'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="p">...</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>Suites also share a functional scope and so it's possible to declare variables and functions inside a describe block which are accessible within specs:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s1">'Stats'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="nx">it</span><span class="p">(</span><span class="s1">'can increment a number'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">// the counter was = 1</span>
        <span class="nx">counter</span> <span class="o">=</span> <span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">counter</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">it</span><span class="p">(</span><span class="s1">'can subtract a number'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">// the counter was = 2</span>
        <span class="nx">counter</span> <span class="o">=</span> <span class="nx">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">counter</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p><strong><em>Note:</em></strong> Suites are executed in the order in which they are described, which can be useful to know if you would prefer to see test results for specific parts of your application reported first.</p>

<p>Jasmine also supports <strong>spies</strong> - a way to mock, spy and fake behavior in our unit tests. Spies replace the function they're spying on, allowing us to simulate behavior we would like to mock (i.e test free of the actual implementation).</p>

<p>In the below example, we're spying on the <code>setComplete</code> method of a dummy Todo function to test that arguments can be passed to it as expected. </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Todo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
<span class="p">};</span>

<span class="nx">Todo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setComplete</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arg</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">'a simple spy'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">'should spy on an instance method of a Todo'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">myTodo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">();</span>
        <span class="nx">spyOn</span><span class="p">(</span><span class="nx">myTodo</span><span class="p">,</span> <span class="s1">'setComplete'</span><span class="p">);</span>
        <span class="nx">myTodo</span><span class="p">.</span><span class="nx">setComplete</span><span class="p">(</span><span class="s1">'foo bar'</span><span class="p">);</span>

        <span class="nx">expect</span><span class="p">(</span><span class="nx">myTodo</span><span class="p">.</span><span class="nx">setComplete</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="s1">'foo bar'</span><span class="p">);</span>

        <span class="kd">var</span> <span class="nx">myTodo2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">();</span>
        <span class="nx">spyOn</span><span class="p">(</span><span class="nx">myTodo2</span><span class="p">,</span> <span class="s1">'setComplete'</span><span class="p">);</span>

        <span class="nx">expect</span><span class="p">(</span><span class="nx">myTodo2</span><span class="p">.</span><span class="nx">setComplete</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>

    <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>What you're more likely to use spies for is testing <a href="http://en.wikipedia.org/wiki/Asynchronous_communication">asynchronous</a> behavior in your application such as AJAX requests. Jasmine supports:</p>

<ul>
<li>Writing tests which can mock AJAX requests using spies. This allows us to test code which runs before an AJAX request and right after. It's also possible to mock/fake responses the server can return and the benefit of this type of testing is that it's faster as no real calls are being made to a server</li>
<li>Asynchronous tests which don't rely on spies</li>
</ul><p>For the first kind of test, it's possible to both fake an AJAX request and verify that the request was both calling the correct URL and executed a callback where one was provided.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s2">"the callback should be executed on success"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">spyOn</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">).</span><span class="nx">andCallFake</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">options</span><span class="p">.</span><span class="nx">success</span><span class="p">();</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">();</span>
    <span class="nx">getTodo</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

    <span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">mostRecentCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">"url"</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="s2">"/todos/15"</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">callback</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
<span class="p">});</span>

<span class="kd">function</span> <span class="nx">getTodo</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s2">"GET"</span><span class="p">,</span>
        <span class="nx">url</span><span class="o">:</span> <span class="s2">"/todos/"</span> <span class="o">+</span> <span class="nx">id</span><span class="p">,</span>
        <span class="nx">dataType</span><span class="o">:</span> <span class="s2">"json"</span><span class="p">,</span>
        <span class="nx">success</span><span class="o">:</span> <span class="nx">callback</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>

<p>If you feel lost having seen matchers like <code>andCallFake()</code> and <code>toHaveBeenCalled()</code>, don't worry. All of these are Spy-specific matchers and are documented on the Jasmine <a href="https://github.com/pivotal/jasmine/wiki/Spies">wiki</a>.</p>

<p>For the second type of test (asynchronous tests), we can take the above further by taking advantage of three other methods Jasmine supports:</p>

<ul>
<li>runs(function) - a block which runs as if it was directly called</li>
<li>waits(timeout) - a native timeout before the next block is run</li>
<li>waitsFor(function, optional message, optional timeout) - a way to pause specs until some other work has completed. Jasmine waits until the supplied function returns true here before it moves on to the next block.</li>
</ul><div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s2">"should make an actual AJAX request to a server"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">();</span>
    <span class="nx">getTodo</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

    <span class="nx">waitsFor</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">callback</span><span class="p">.</span><span class="nx">callCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="nx">runs</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">callback</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="kd">function</span> <span class="nx">getTodo</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s2">"GET"</span><span class="p">,</span>
        <span class="nx">url</span><span class="o">:</span> <span class="s2">"todos.json"</span><span class="p">,</span>
        <span class="nx">dataType</span><span class="o">:</span> <span class="s2">"json"</span><span class="p">,</span>
        <span class="nx">success</span><span class="o">:</span> <span class="nx">callback</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>

<p><strong><em>Note:</em></strong> It's useful to remember that when making real requests to a web server in your unit tests, this has the potential to massively slow down the speed at which tests run (due to many factors including server latency). As this also introduces an external dependency that can (and should) be minimized in your unit testing, it is strongly recommended that you opt for spies to remove the need for a web server to be used here.</p>

<h2>beforeEach and afterEach()</h2>

<p>Jasmine also supports specifying code that can be run before each (<code>beforeEach()</code>) and after each (<code>afterEach</code>) test. This is useful for enforcing consistent conditions (such as resetting variables that may be required by specs). In the following example, <code>beforeEach()</code> is used to create a new sample Todo model specs can use for testing attributes.</p>

<div class="highlight"><pre><span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">({</span>
      <span class="nx">text</span><span class="o">:</span> <span class="s2">"Buy some more groceries"</span><span class="p">,</span>
      <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> 
   <span class="p">});</span>
<span class="p">});</span>

<span class="nx">it</span><span class="p">(</span><span class="s2">"should contain a text value if not the default value"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="s2">"Buy some more groceries"</span><span class="p">);</span> 
<span class="p">});</span>
</pre></div>

<p>Each nested <code>describe()</code> in your tests can have their own <code>beforeEach()</code> and <code>afterEach()</code> methods which support including setup and teardown methods relevant to a particular suite. We'll be using <code>beforeEach()</code> in practice a little later.</p>

<h2>Shared scope</h2>

<p>In the previous section you may have noticed that we initially declared a variable <code>this.todo</code> in our <code>beforeEach()</code> call and were then able to continue using this in <code>afterEach()</code>. This is thanks to a powerful feature of Jasmine known as shared  functional scope. Shared scope allows <code>this</code> properties to be common to all blocks (including <code>runs()</code>), but not declared variables (i.e <code>var</code>s). </p>

<h2>Getting setup</h2>

<p>Now that we've reviewed some fundamentals, let's go through downloading Jasmine and getting everything setup to write tests. </p>

<p>A standalone release of Jasmine can be <a href="http://pivotal.github.com/jasmine/download.html">downloaded</a> from the official release page. </p>

<p>You'll need a file called SpecRunner.html in addition to the release. It can be downloaded from <a href="https://github.com/pivotal/jasmine/tree/master/lib/jasmine-core/example">https://github.com/pivotal/jasmine/tree/master/lib/jasmine-core/example</a> or as part of a download of the complete Jasmine <a href="https://github.com/pivotal/jasmine/zipball/master">repo</a>.Alternatively, you can <code>git clone</code> the main Jasmine repository from <a href="https://github.com/pivotal/jasmine.git">https://github.com/pivotal/jasmine.git</a>. </p>

<p>Let's review <a href="https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/example/SpecRunner.html">SpecRunner.html</a>:</p>

<p>It first includes both Jasmine and the necessary CSS required for reporting:</p>

<div class="highlight"><pre><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"lib/jasmine-1.1.0.rc1/jasmine.css"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"lib/jasmine-1.1.0.rc1/jasmine.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"lib/jasmine-1.1.0.rc1/jasmine-html.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>Next, some sample tests are included:</p>

<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"spec/SpecHelper.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"spec/PlayerSpec.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>And finally the sources being tested:</p>

<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"src/Player.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"src/Song.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p><strong><em>Note:</em></strong> Below this section of SpecRunner is code responsible for running the actual tests. Given that we won't be covering modifying this code, I'm going to skip reviewing it. I do however encourage you to take a look through <a href="https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/example/spec/PlayerSpec.js">PlayerSpec.js</a> and <a href="https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/example/spec/SpecHelper.js">SpecHelper.js</a>. They're a useful basic example to go through how a minimal set of tests might work.</p>

<h2>TDD With Backbone</h2>

<p>When developing applications with Backbone, it can be necessary to test both individual modules of code as well as modules, views, collections and routers. Taking a TDD approach to testing, let's review some specs for testing these Backbone components using the popular Backbone <a href="https://github.com/addyosmani/todomvc/tree/master/todo-example/backbone">Todo</a> application. </p>

<p>I would like to extend my thanks to Larry Myers for his <a href="https://github.com/addyosmani/backbone-koans">Koans</a> project which both greatly helped here and will be used in the exercise portion of this chapter.</p>

<h2><a name="testing-models">Models</a></h2>

<p>The complexity of Backbone models can vary greatly depending on what your application is trying to achieve. In the following example, we're going to test default values, attributes, state changes and validation rules.  </p>

<p>First, we begin our suite for model testing using <code>describe()</code>:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s1">'Tests for Todo'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</pre></div>

<p>Models should ideally have default values for attributes. This helps ensure that when creating instances without a value set for any specific attribute, a default one (e.g "") is used instead. The idea here is to allow your application to interact with models without any unexpected behavior. </p>

<p>In the following spec, we create a new Todo without any attributes passed then check to find out what the value of the <code>text</code> attribute is. As no value has been set, we expect a default value of `<code>""</code> to be returned.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Can be created with default values for its attributes.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">();</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">""</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>If testing this spec before your models have been written, you'll incur a failing test, as expected. What's required for the spec to pass is a default value for the attribute <code>text</code>. We can implement this default value with some other useful defaults (which we'll be using shortly) in our Todo model as follows:</p>

<div class="highlight"><pre><span class="nb">window</span><span class="p">.</span><span class="nx">Todo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="nx">defaults</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">text</span><span class="o">:</span> <span class="s2">""</span><span class="p">,</span>
            <span class="nx">done</span><span class="o">:</span>  <span class="kc">false</span><span class="p">,</span>
            <span class="nx">order</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">};</span>
    <span class="p">}</span>
</pre></div>

<p>Next, we want to test that our model will pass attributes that are set such that retrieving the value of these attributes after initialization will be what we expect. Notice that here, in addition to testing for an expected value for <code>text</code>, we're also testing the other default values are what we expect them to be.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Will set passed attributes on the model instance when created.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">({</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">'Get oil change for car.'</span> <span class="p">});</span>

    <span class="c1">// what are the values expected here for each of the</span>
    <span class="c1">// attributes in our Todo?</span>

    <span class="nx">expect</span><span class="p">(</span><span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">"Get oil change for car."</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'done'</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'order'</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>Backbone models support a model.change() event which is triggered when the state of a model changes. In the following example, by 'state' I'm referring to the value of a Todo model's attributes. The reason changes of state are important to test are that there may be state-dependent events in your application e.g you may wish to display a confirmation view once a Todo model has been updated.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Fires a custom event when the state changes.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="s1">'-change event callback-'</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">();</span>

    <span class="c1">// how do we monitor changes of state?</span>
    <span class="nx">todo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'change'</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>

    <span class="c1">// what would you need to do to force a change of state?</span>
    <span class="nx">todo</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">'Get oil change for car.'</span> <span class="p">});</span>

    <span class="nx">expect</span><span class="p">(</span><span class="nx">spy</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>

<p>It's common to include validation logic in your models to ensure both the input passed from users (and other modules) in the application are 'valid'. A Todo app may wish to validate the text input supplied in case it contains rude words. Similarly if we're storing the <code>done</code> state of a Todo item using booleans, we need to validate that truthy/falsy values are passed and not just any arbitrary string. </p>

<p>In the following spec, we take advantage of the fact that validations which fail model.validate() trigger an "error" event. This allows us to test if validations are correctly failing when invalid input is supplied. </p>

<p>We create an errorCallback spy using Jasmine's built in <code>createSpy()</code> method which allows us to spy on the error event as follows:</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Can contain custom validation rules, and will trigger an error event on failed validation.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">errorCallback</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="s1">'-error event callback-'</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">();</span>

    <span class="nx">todo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">errorCallback</span><span class="p">);</span>

    <span class="c1">// What would you need to set on the todo properties to </span>
    <span class="c1">// cause validation to fail?</span>

    <span class="nx">todo</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="nx">done</span><span class="o">:</span><span class="s1">'a non-integer value'</span><span class="p">});</span>

    <span class="kd">var</span> <span class="nx">errorArgs</span> <span class="o">=</span> <span class="nx">errorCallback</span><span class="p">.</span><span class="nx">mostRecentCall</span><span class="p">.</span><span class="nx">args</span><span class="p">;</span>

    <span class="nx">expect</span><span class="p">(</span><span class="nx">errorArgs</span><span class="p">).</span><span class="nx">toBeDefined</span><span class="p">();</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">errorArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">todo</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">errorArgs</span><span class="p">[</span><span class="mi">1</span><span class="p">]).</span><span class="nx">toBe</span><span class="p">(</span><span class="s1">'Todo.done must be a boolean value.'</span><span class="p">);</span>
<span class="p">});</span>

</pre></div>

<p>The code to make the above failing test support validation is relatively simple. In our model, we override the validate() method (as recommended in the Backbone docs), checking to make sure a model both has a 'done' property and is a valid boolean before allowing it to pass.</p>

<div class="highlight"><pre><span class="nx">validate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">attrs</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">'done'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">_</span><span class="p">.</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">attrs</span><span class="p">.</span><span class="nx">done</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s1">'Todo.done must be a boolean value.'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>If you would like to review the final code for our Todo model, you can find it below:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">NAUGHTY_WORDS</span> <span class="o">=</span> <span class="sr">/crap|poop|hell|frogs/gi</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">sanitize</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">NAUGHTY_WORDS</span><span class="p">,</span> <span class="s1">'rainbows'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">Todo</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

    <span class="nx">defaults</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">text</span><span class="o">:</span> <span class="s1">''</span><span class="p">,</span>
            <span class="nx">done</span><span class="o">:</span>  <span class="kc">false</span><span class="p">,</span>
            <span class="nx">order</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">};</span>
    <span class="p">},</span>

    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="nx">text</span><span class="o">:</span> <span class="nx">sanitize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">))},</span> <span class="p">{</span><span class="nx">silent</span><span class="o">:</span> <span class="kc">true</span><span class="p">});</span>
    <span class="p">},</span>

    <span class="nx">validate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">attrs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">attrs</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">'done'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">_</span><span class="p">.</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">attrs</span><span class="p">.</span><span class="nx">done</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s1">'Todo.done must be a boolean value.'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span>

    <span class="nx">toggle</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">save</span><span class="p">({</span><span class="nx">done</span><span class="o">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"done"</span><span class="p">)});</span>
    <span class="p">}</span>

<span class="p">});</span>
</pre></div>

<h2><a name="testing-collections">Collections</a></h2>

<p>We now need to define specs to tests a Backbone collection of Todo models (a TodoList). Collections are responsible for a number of list tasks including managing order and filtering.</p>

<p>A few specific specs that come to mind when working with collections are:</p>

<ul>
<li>Making sure we can add new Todo models as both objects and arrays</li>
<li>Attribute testing to make sure attributes such as the base URL of the collection are values we expect</li>
<li>Purposefully adding items with a status of <code>done:true</code> and checking against how many items the collection thinks have been completed vs. those that are remaining</li>
</ul><p>In this section we're going to cover the first two of these with the third left as an extended exercise I recommend trying out.</p>

<p>Testing Todo models can be added to a collection as objects or arrays is relatively trivial. First, we initialize a new TodoList collection and check to make sure it's length (i.e the number of Todo models it contains) is 0. Next, we add new Todos, both as objects and arrays, checking the length property of the collection at each stage to ensure the overall count is what we expect:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s1">'Tests for TodoList'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">it</span><span class="p">(</span><span class="s1">'Can add Model instances as objects and arrays.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">todos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TodoList</span><span class="p">();</span>

        <span class="nx">expect</span><span class="p">(</span><span class="nx">todos</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="nx">todos</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">'Clean the kitchen'</span> <span class="p">});</span>

        <span class="c1">// how many todos have been added so far?</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">todos</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="nx">todos</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span>
            <span class="p">{</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">'Do the laundry'</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">},</span> 
            <span class="p">{</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">'Go to the gym'</span><span class="p">}</span>
        <span class="p">]);</span>

        <span class="c1">// how many are there in total now?</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">todos</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">...</span>
</pre></div>

<p>Similar to model attributes, it's also quite straight-forward to test attributes in collections. Here we have a spec that ensures the collection.url (i.e the url reference to the collection's location on the server) is what we expect it to be:</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Can have a url property to define the basic url structure for all contained models.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">todos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TodoList</span><span class="p">();</span>

        <span class="c1">// what has been specified as the url base in our model?</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">todos</span><span class="p">.</span><span class="nx">url</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="s1">'/todos/'</span><span class="p">);</span>
<span class="p">});</span>

</pre></div>

<p>For the third spec, it's useful to remember that the implementation for our collection will have methods for filtering how many Todo items are done and how many are remaining - we can call these <code>done()</code> and <code>remaining()</code>. Consider writing a spec which creates a new collection and adds one new model that has a preset <code>done</code> state of <code>true</code> and two others that have the default <code>done</code> state of <code>false</code>. Testing the length of what's returned using <code>done()</code> and <code>remaining()</code> should allow us to know whether the state management in our application is working or needs a little tweaking.</p>

<p>The final implementation for our TodoList collection can be found below:</p>

<div class="highlight"><pre> <span class="nb">window</span><span class="p">.</span><span class="nx">TodoList</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="nx">model</span><span class="o">:</span> <span class="nx">Todo</span><span class="p">,</span>

        <span class="nx">url</span><span class="o">:</span> <span class="s1">'/todos/'</span><span class="p">,</span>

        <span class="nx">done</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">todo</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'done'</span><span class="p">);</span> <span class="p">});</span>
        <span class="p">},</span>

        <span class="nx">remaining</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">without</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">done</span><span class="p">());</span>
        <span class="p">},</span>

        <span class="nx">nextOrder</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span> 
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> 
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">last</span><span class="p">().</span><span class="nx">get</span><span class="p">(</span><span class="s1">'order'</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="nx">comparator</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'order'</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">});</span>
</pre></div>

<h2><a name="testing-views">Views</a></h2>

<p>Before we take a look at testing Backbone views, let's briefly review a jQuery plugin that can assist with writing Jasmine specs for them.</p>

<p><strong>The Jasmine jQuery Plugin</strong></p>

<p>As we know our Todo application will be using jQuery for DOM manipulation, there's a useful jQuery plugin called <a href="https://github.com/velesin/jasmine-jquery">jasmine-jquery</a> we can use to help simplify BDD testing rendered elements that our views may produce. </p>

<p>The plugin provides a number of additional Jasmine <a href="https://github.com/pivotal/jasmine/wiki/Matchers">matchers</a> to help test jQuery wrapped sets such as:</p>

<ul>
<li>
<code>toBe(jQuerySelector)</code> e.g <code>expect($('&lt;div id="some-id"&gt;&lt;/div&gt;')).toBe('div#some-id')</code>
</li>
<li>
<code>toBeChecked()</code> e.g <code>expect($('&lt;input type="checkbox" checked="checked"/&gt;')).toBeChecked()</code>
</li>
<li>
<code>toBeSelected()</code> e.g <code>expect($('&lt;option selected="selected"&gt;&lt;/option&gt;')).toBeSelected()</code>
</li>
</ul><p>and <a href="https://github.com/velesin/jasmine-jquery">many others</a>. The complete list of matchers supported can be found on the project homepage. It's useful to know that similar to the standard Jasmine matchers, the custom matchers above can be inverted using the .not prefix (i.e <code>expect(x).not.toBe(y)</code>):</p>

<p><code>expect($('&lt;div&gt;I am an example&lt;/div&gt;')).not.toHaveText(/other/)</code></p>

<p>jasmine-jquery also includes a fixtures model, allowing us to load in arbitrary HTML content we may wish to use in our tests. Fixtures can be used as follows:</p>

<p>Include some HTML in an external fixtures file:</p>

<p>some.fixture.html:
<code>&lt;div id="sample-fixture"&gt;some HTML content&lt;/div&gt;</code></p>

<p>Next, inside our actual test we would load it as follows:</p>

<div class="highlight"><pre><span class="nx">loadFixtures</span><span class="p">(</span><span class="s1">'some.fixture.html'</span><span class="p">)</span>
<span class="nx">$</span><span class="p">(</span><span class="s1">'some-fixture'</span><span class="p">).</span><span class="nx">myTestedPlugin</span><span class="p">();</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#some-fixture'</span><span class="p">)).</span><span class="nx">to</span><span class="o">&lt;</span><span class="nx">the</span> <span class="nx">rest</span> <span class="nx">of</span> <span class="nx">your</span> <span class="nx">matcher</span> <span class="nx">would</span> <span class="nx">go</span> <span class="nx">here</span><span class="o">&gt;</span>
</pre></div>

<p>The jasmine-jquery plugin is by default setup to load fixtures from a specific directory: spec/javascripts/fixtures. If you wish to configure this path you can do so by initially setting <code>jasmine.getFixtures().fixturesPath = 'your custom path'</code>.</p>

<p>Finally, jasmine-jquery includes support for spying on jQuery events without the need for any extra plumbing work. This can be done using the <code>spyOnEvent()</code> and <code>assert(eventName).toHaveBeenTriggered(selector)</code> functions. An example of usage may look as follows:</p>

<div class="highlight"><pre><span class="nx">spyOnEvent</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#el'</span><span class="p">),</span> <span class="s1">'click'</span><span class="p">);</span>
<span class="nx">$</span><span class="p">(</span><span class="s1">'#el'</span><span class="p">).</span><span class="nx">click</span><span class="p">();</span>
<span class="nx">expect</span><span class="p">(</span><span class="s1">'click'</span><span class="p">).</span><span class="nx">toHaveBeenTriggeredOn</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#el'</span><span class="p">));</span>
</pre></div>

<p><strong>View testing</strong></p>

<p>In this section we will review three dimensions to writing specs for Backbone Views: initial setup, view rendering and finally templating. The latter two of these are the most commonly tested, however we'll review shortly why writing specs for the initialization of your views can also be of benefit.</p>

<h2>Initial setup</h2>

<p>At their most basic, specs for Backbone views should validate that they are being correctly tied to specific DOM elements and are backed by valid data models. The reason to consider doing this is that failures to such specs can trip up more complex tests later on and they're fairly simple to write, given the overall value offered.</p>

<p>To help ensure a consistent testing setup for our specs, we use <code>beforeEach()</code> to append both an empty <code>UL</code> (#todoList) to the DOM and initialize a new instance of a TodoView using an empty Todo model. <code>afterEach()</code> is used to remove the previous #todoList  <code>UL</code> as well as the previous instance of the view. </p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s1">'Tests for TodoView'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'body'</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">'&lt;ul id="todoList"&gt;&lt;/ul&gt;'</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">todoView</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TodoView</span><span class="p">({</span> <span class="nx">model</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Todo</span><span class="p">()</span> <span class="p">});</span>
    <span class="p">});</span>


    <span class="nx">afterEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">todoView</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'#todoList'</span><span class="p">).</span><span class="nx">remove</span><span class="p">();</span>
    <span class="p">});</span>

<span class="p">...</span>
</pre></div>

<p>The first spec useful to write is a check that the TodoView we've created is using the correct <code>tagName</code> (element or className). The purpose of this test is to make sure it's been correctly tied to a DOM element when it was created.</p>

<p>Backbone views typically create empty DOM elements once initialized, however these elements are not attached to the visible DOM in order to allow them to be constructed without an impact on the performance of rendering. </p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Should be tied to a DOM element when created, based off the property provided.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//what html element tag name represents this view?</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">todoView</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">tagName</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="s1">'li'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>Once again, if the TodoView has not already been written, we will experience failing specs. Thankfully, solving this is as simple as creating a new Backbone.View with a specific <code>tagName</code>.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">todoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">tagName</span><span class="o">:</span>  <span class="s2">"li"</span>
<span class="p">});</span>
</pre></div>

<p>If instead of testing against the <code>tagName</code> you would prefer to use a className instead, we can take advantage of jasmine-jquery's <code>toHaveClass()</code> matcher to cater for this.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Should have a class of "todos"'</span><span class="p">),</span> <span class="kd">function</span><span class="p">(){</span>
   <span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">el</span><span class="p">)).</span><span class="nx">toHaveClass</span><span class="p">(</span><span class="s1">'todos'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>The <code>toHaveClass()</code> matcher operates on jQuery objects and if the plugin hadn't been used, an exception would have been incurred (it is of course also possible to test for the className by accessing el.className if not opting to use jasmine-jquery).</p>

<p>You may have noticed that in <code>beforeEach()</code>, we passed our view an initial (albeit unfilled) Todo model. Views should be backed by a model instance which provides data. As this is quite important to our view's ability to function, we can write a spec to ensure a model is both defined (using the <code>toBeDefined()</code> matcher) and then test attributes of the model to ensure defaults both exist and are the value we expect them to be.</p>

<div class="highlight"><pre><span class="nx">it</span><span class="p">(</span><span class="s1">'Is backed by a model instance, which provides the data.'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">expect</span><span class="p">(</span><span class="nx">todoView</span><span class="p">.</span><span class="nx">model</span><span class="p">).</span><span class="nx">toBeDefined</span><span class="p">();</span>

    <span class="c1">// what's the value for Todo.get('done') here?</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">todoView</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'done'</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">//or toBeFalsy()</span>
<span class="p">});</span>
</pre></div>

<h2>View rendering</h2>

<p>Next we're going to take a look at writing specs for view rendering. Specifically, we want to test that our TodoView elements are actually rendering as expected. </p>

<p>In smaller applications, those new to BDD might argue that visual confirmation of view rendering could replace unit testing of views. The reality is that when dealing with applications that might grow to multiple-views, it often makes sense to automate this process as much as possible from the get-go. There are also aspects of rendering that require verification beyond what is visually presented on-screen (which we'll see very shortly).</p>

<p>We're going to begin testing views by writing two specs. The first spec will check that the view's <code>render()</code> method is correctly returning the view instance, which is necessary for chaining. Our second spec will check that the HTML produced is exactly what we expect based on the properties of the model instance that's been associated with our TodoView.</p>

<p>Unlike some of the previous specs we've covered, this section will make greater use of <code>beforeEach()</code> to both demonstrate how to use nested suites and also ensure a consistent set of conditions for our specs. In our first view spec for TodoView, we're simply going to create a sample model (based on Todo) and instantiate a TodoView which associates it with the model.</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s2">"TodoView"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">({</span>
      <span class="nx">text</span><span class="o">:</span> <span class="s2">"My Todo"</span><span class="p">,</span>
      <span class="nx">order</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span>
    <span class="p">});</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TodoView</span><span class="p">({</span><span class="nx">model</span><span class="o">:</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">});</span>
  <span class="p">});</span>

  <span class="nx">describe</span><span class="p">(</span><span class="s2">"Rendering"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">it</span><span class="p">(</span><span class="s2">"returns the view object"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">it</span><span class="p">(</span><span class="s2">"produces the correct HTML"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span>

      <span class="c1">//let's use jasmine-jquery's toContain() to avoid</span>
      <span class="c1">//testing for the complete content of a todo's markup</span>
      <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">toContain</span><span class="p">(</span><span class="s1">'&lt;label class="todo-content"&gt;My Todo&lt;/label&gt;'</span><span class="p">);</span>
    <span class="p">});</span>

  <span class="p">});</span>

<span class="p">});</span>
</pre></div>

<p>Once these specs are run, only the second one ('produces the correct HTML') fails. Our first spec ('returns the view object'), which is testing that the TodoView instance is returned from <code>render()</code>, only passed as this is Backbone's default behavior. We haven't yet overwritten the <code>render()</code> method with our own version.</p>

<p><strong>Note:</strong> For the purposes of maintaining readability, all template examples in this section will use a minimal version of the following Todo view template. As it's relatively trivial to expand this, please feel free to refer to this sample if needed: </p>

<div class="highlight"><pre><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"todo &lt;%= done ? 'done' : '' %&gt;"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"display"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;input</span> <span class="na">class=</span><span class="s">"check"</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="err">&lt;%=</span> <span class="na">done</span> <span class="err">?</span> <span class="err">'</span><span class="na">checked=</span><span class="s">"checked"</span><span class="err">'</span> <span class="na">:</span> <span class="err">''</span> <span class="err">%</span><span class="nt">&gt;</span> /&gt;
          <span class="nt">&lt;label</span> <span class="na">class=</span><span class="s">"todo-content"</span><span class="nt">&gt;</span><span class="err">&lt;</span>%= text %&gt;<span class="nt">&lt;/label&gt;</span>
          <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"todo-destroy"</span><span class="nt">&gt;&lt;/span&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"edit"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;input</span> <span class="na">class=</span><span class="s">"todo-input"</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">value=</span><span class="s">"&lt;%= content %&gt;"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>The second spec fails with the following message:</p>

<p>Expected '' to contain <code>'&lt;label class="todo-content"&gt;My Todo&lt;/label&gt;'</code>.</p>

<p>The reason for this is the default behavior for render() doesn't create any markup. Let's write a replacement for render() which fixes this:</p>

<div class="highlight"><pre><span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">template</span> <span class="o">=</span> <span class="s1">'&lt;label class="todo-content"&gt;&lt;%= text %&gt;&lt;/label&gt;'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">template</span>
    <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">"&lt;%= text %&gt;"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">));</span>
  <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The above specifies an inline string template and replaces fields found in the template within the "&lt;% %&gt;" blocks with their corresponding values from the associated model. As we're now also returning the TodoView instance from the method, the first spec will also pass. It's worth noting that there are serious drawbacks to using HTML strings in your specs to test against like this. Even minor changes to your template (a simple tab or whitespace) would cause your spec to fail, despite the rendered output being the same. It's also more time consuming to maintain as most templates in real-world applications are significantly more complex. A better option for testing rendered output is using jQuery to both select and inspect values. </p>

<p>With this in mind, let's re-write the specs, this time using some of the custom matchers offered by jasmine-jquery:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s2">"Template"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span>
  <span class="p">});</span>

  <span class="nx">it</span><span class="p">(</span><span class="s2">"has the correct text content"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="s1">'todo-content'</span><span class="p">))</span>
      <span class="p">.</span><span class="nx">toHaveText</span><span class="p">(</span><span class="s1">'My Todo'</span><span class="p">);</span>
  <span class="p">});</span>

<span class="p">});</span>
</pre></div>

<p>It would be impossible to discuss unit testing without mentioning fixtures. Fixtures typically contain test data (e.g HTML) that is loaded in when needed (either locally or from an external file) for unit testing. So far we've been establishing jQuery expectations based on the view's el property. This works for a number of cases, however, there are instances where it may be necessary to render markup into the document. The most optimal way to handle this within specs is through using fixtures (another feature brought to us by the jasmine-jquery plugin).</p>

<p>Re-writing the last spec to use fixtures would look as follows:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s2">"TodoView"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">setFixtures</span><span class="p">(</span><span class="s1">'&lt;ul class="todos"&gt;&lt;/ul&gt;'</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="p">...</span>

  <span class="nx">describe</span><span class="p">(</span><span class="s2">"Template"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">$</span><span class="p">(</span><span class="s1">'.todos'</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">().</span><span class="nx">el</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">it</span><span class="p">(</span><span class="s2">"has the correct text content"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todos'</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="s1">'.todo-content'</span><span class="p">))</span>
        <span class="p">.</span><span class="nx">toHaveText</span><span class="p">(</span><span class="s1">'My Todo'</span><span class="p">);</span>
    <span class="p">});</span>

  <span class="p">});</span>

<span class="p">});</span>
</pre></div>

<p>What we're now doing in the above spec is appending the rendered todo item into the fixture. We then set expectations against the fixture, which may be something desirable when a view is setup against an element which already exists in the DOM. It would be necessary to provide both the fixture and test the <code>el</code> property correctly picking up the element expected when the view is instantiated.</p>

<h2>Rendering with a templating system</h2>

<p>JavaScript templating systems (such as Handlebars, Mustache and even Underscore's own Micro-templating) support conditional logic in template strings. What this effectively means is that we can add if/else/ternery expressions inline which can then be evaluated as needed, allowing us to build even more powerful templates. </p>

<p>In our case, when a user sets a Todo item to be complete (done), we may wish to provide them with visual feedback (such as a striked line through the text) to differentiate the item from those that are remaining. This can be done by attaching a new class to the item. Let's begin by writing a test we would ideally like to work:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s2">"When a todo is done"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">},</span> <span class="p">{</span><span class="nx">silent</span><span class="o">:</span> <span class="kc">true</span><span class="p">});</span>
    <span class="nx">$</span><span class="p">(</span><span class="s1">'.todos'</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">render</span><span class="p">().</span><span class="nx">el</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">it</span><span class="p">(</span><span class="s2">"has a done class"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'.todos .todo-content:first-child'</span><span class="p">))</span>
      <span class="p">.</span><span class="nx">toHaveClass</span><span class="p">(</span><span class="s2">"done"</span><span class="p">);</span>
  <span class="p">});</span>

<span class="p">});</span>
</pre></div>

<p>This will fail with the following message:</p>

<p>Expected 'My Todo' 
to have class 'done'.</p>

<p>which can be fixed in the existing render() method as follows:</p>

<div class="highlight"><pre><span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">template</span> <span class="o">=</span> <span class="s1">'&lt;label class="todo-content"&gt;'</span> <span class="o">+</span>
    <span class="s1">'&lt;%= text %&gt;&lt;/label&gt;'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">template</span>
    <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">"&lt;%= text %&gt;"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'text'</span><span class="p">));</span>
  <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'done'</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$</span><span class="p">(</span><span class="s2">".todo-content"</span><span class="p">).</span><span class="nx">addClass</span><span class="p">(</span><span class="s2">"done"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>This can however get unwieldily fairly quickly. As the logic in our templates increases, so does the complexity involved. This is where templates libraries can help. As mentioned earlier, there are a number of popular options available, but for the purposes of this chapter we're going to stick to using Underscore's built-in Microtemplating. Whilst there are more advanced options you're free to explore, the benefit of this is that no additional files are required and we can easily change the existing Jasmine specs without too much adjustment.</p>

<p>The TodoView object modified to use Underscore templating would look as follows:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">TodoView</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="nx">tagName</span><span class="o">:</span> <span class="s2">"li"</span><span class="p">,</span>

  <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">template</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">template</span> <span class="o">||</span> <span class="s2">""</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()));</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">...</span>

<span class="p">});</span>
</pre></div>

<p>Above, the initialize() method compiles a supplied Underscore template (using the _.template() function) in the instantiation. A more common way of referencing templates is placing them in a script tag using a custom script type (e.g type="text/template"). As this isn't a script type any browser understands, it's simply ignored, however referencing the script by an id attribute allows the template to be kept separate to other parts of the page which wish to use it. In real world applications, it's preferable to either do this or load in templates stored in external files for testing. </p>

<p>For testing purposes, we're going to continue using the string injection approach to keep things simple. There is however a useful trick that can be applied to automatically create or extend templates in the Jasmine scope for each test. By creating a new directory (say, 'templates') in the 'spec' folder and adding a new script file with the following contents, to jasmine.yml or SpecRunner.html, we can add a todo property which contains the Underscore template we wish to use:</p>

<div class="highlight"><pre><span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">templates</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">templates</span> <span class="o">||</span> <span class="p">{},</span> <span class="p">{</span>
    <span class="nx">todo</span><span class="o">:</span> <span class="s1">'&lt;label class="todo-content"&gt;'</span> <span class="o">+</span>
            <span class="s1">'&lt;%= text %&gt;'</span> <span class="o">+</span>
          <span class="s1">'&lt;/label&gt;'</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>To finish this off, we simply update our existing spec to reference the template when instantiating the TodoView object:</p>

<div class="highlight"><pre><span class="nx">describe</span><span class="p">(</span><span class="s2">"TodoView"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TodoView</span><span class="p">({</span>
      <span class="nx">model</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span>
      <span class="nx">template</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nx">todo</span>
    <span class="p">});</span>
  <span class="p">});</span>

  <span class="p">...</span>

<span class="p">});</span>
</pre></div>

<p>The existing specs we've looked at would continue to pass using this approach, leaving us free to adjust the template with some additional conditional logic for Todos with a status of 'done':</p>

<div class="highlight"><pre><span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">templates</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">templates</span> <span class="o">||</span> <span class="p">{},</span> <span class="p">{</span>
    <span class="nx">todo</span><span class="o">:</span> <span class="s1">'&lt;label class="todo-content &lt;%= done ? '</span><span class="nx">done</span><span class="s1">' : '' %&gt;"'</span> <span class="o">+</span>
            <span class="s1">'&lt;%= text %&gt;'</span> <span class="o">+</span>
          <span class="s1">'&lt;/label&gt;'</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>This will now also pass without any issues. Remember that jasmine-jquery also supports loading external fixtures into your specs easily using it's build in <code>loadFixtures()</code> and <code>readFixtures()</code> methods. For more information, consider reading the official jasmine-jquery <a href="https://github.com/velesin/jasmine-jquery">docs</a>.</p>

<h2>Conclusions</h2>

<p>We have now covered how to write Jasmine tests for models, views and collections with Backbone.js. Whilst testing routing can at times be desirable, some developers feel it can be more optimal to leave this to third-party tools such as Selenium, so do keep this in mind.</p>

<p>James Newbery was kind enough to help me with writing the Views section above and his articles on <a href="http://tinnedfruit.com/2011/04/26/testing-backbone-apps-with-jasmine-sinon-3.html">Testing Backbone Apps With SinonJS</a> were of great inspiration (you'll actually find some Handlebars examples of the view specs in part 3 of his article). If you would like to learn more about writing spies and mocks for Backbone using <a href="http://sinonjs.org">SinonJS</a> as well as how to test Backbone routers, do consider reading his series.</p>

<h2>Exercise</h2>

<p>As an exercise, I recommend now downloading <a href="http://github.com/addyosmani/backbone-koans">Backbone Koans</a> and trying to fix some of the purposefully failing tests it has to offer. This is an excellent way of not just learning how Jasmine specs and suites work, but working through the examples (without peaking back) will also put your Backbone skills to test too.</p>

<p><strong>Note</strong>: I've linked to this book's fork of Koans in case any project-specific changes are required, however, in case you would like to check out the original project on GitHub, please feel <a href="https://github.com/larrymyers/backbone-koans">free</a> to.</p>

<h2>Further reading</h2>

<ul>
<li><a href="http://japhr.blogspot.com/2011/11/jasmine-backbonejs-revisited.html">Jasmine + Backbone Revisited</a></li>
<li><a href="http://japhr.blogspot.com/2011/12/phantomjs-and-backbonejs-and-requirejs.html">Backbone, PhantomJS and Jasmine</a></li>
</ul><h1><a name="resources">Resources</a></h1>

<p>Whilst we get with Backbone out of the box can be terribly useful, there are some equally beneficial add-ons that can help simplify our development process. These include:</p>

<ul>
<li><a href="https://github.com/tbranyen/backbone.layoutmanager">Backbone Layout Manager</a></li>
<li><a href="https://github.com/derickbailey/backbone.modelbinding">Backbone Model Binding</a></li>
<li><a href="https://github.com/PaulUithol/Backbone-relational">Backbone Relational - for model relationships</a></li>
<li><a href="https://gist.github.com/1271041">View and model inheritance</a></li>
<li><a href="https://github.com/janmonschke/backbone-couchdb">Backbone CouchDB</a></li>
<li><a href="https://github.com/n-time/backbone.validations">Backbone Validations - HTML5 inspired validations</a></li>
</ul><p>In time, there will be tutorials in the book covering some of these resources but until then, please feel free to check them out. </p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-36385382-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>